{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#course-summary","title":"Course summary","text":"<p>This is the second part of programming fundamentals, a continuation of C1023 using C++ as the programming language. Principles of object oriented design including encapsulation, inheritance, polymorphism and the use of abstract classes will be introduced. Language features will also include pointers, dynamic memory allocation, operator overloading, exceptions and templates.</p>"},{"location":"#textbooks","title":"Textbooks","text":"<ul> <li> <ul> <li>Starting out with C++ from Control Structure through Objects</li> <li>by Tony Gaddis, </li> <li>10th Edition.</li> </ul> </li> <li> <ul> <li>Absolute C++</li> <li>by Walter Savitch and Kenrick Mock</li> <li>Pearson 2015, 6th Edition</li> </ul> </li> </ul>"},{"location":"#prerequisites","title":"Prerequisites","text":"<ul> <li>C1023</li> </ul>"},{"location":"#grading","title":"Grading","text":"Activity Weight Labs 20% Projects 40% Final Exam 40%"},{"location":"#tentative-schedule","title":"Tentative Schedule","text":"Week # Topic Savitch Gaddis Assignment Week 0 Reviewing Prog. Fund. (1) Week 1 Structures Ch.6 Ch.11 Week 2 Pointers &amp; Dynamic arrays Ch.10 Ch.9 Week 3 Strings, Streams &amp; File I/O Ch.9+12 Ch.10+12 Week 4 Classes Ch.6 Ch.13 Week 5 More about Classes Ch.7 Ch.13+14 Week 6 Operator overloading Ch.8 Ch.14 Week 7 Inheritance &amp; Polymorphism Ch.14+15 Ch.15 Week 8 Exceptions Ch.18 Ch.16 Week 9 Template Ch.16 Ch.16 Week 10 Review"},{"location":"#what-do-you-expect","title":"What do you expect?","text":"<ul> <li>Building a game</li> </ul> <ul> <li>Builidng a system like a banking system</li> </ul>"},{"location":"lectures/lec001/","title":"Lecture 0: Review - Part 1","text":""},{"location":"lectures/lec001/#overview-of-programming","title":"Overview of Programming","text":"<p>We start this review with a quote from very famous computer scientist:</p> <p>Programming is learned by writing programs</p> <p>Brian Kernighan</p> <p>Indeed! If you want to be professional in programming, then you must spend a lot of time (really a lot of time) writing several programs in front of a PC/laptop. Writing codes in a paper is not sufficient. You must write and run your programs. The purpose is to get familiar with programming environment and give you a feel of how you can get a computer to do things for you.</p> <p>Programming</p> <p>Programming is the activity of writing and testing programs</p> <p>The figure below shows a very basic view of the program development process. Generally, programming involves two activities: writing and testing. After designing your algorithm, you go through the following steps:</p> <pre><code>flowchart LR\n    S1[Edit] --&gt; S2[Compile] --&gt; C1{error?} -- No --&gt; S3[Run a test] --&gt; C2{Pass?} -- Yes --&gt; C3{Another test?} -- No --&gt; F(Done)\n    C1 -- Yes --&gt; S1\n    C2 -- No --&gt; S1\n    C3 -- Yes --&gt; S3</code></pre> <ol> <li>Edit your program and save it in a source file,</li> <li>Compile the source file to find any syntax error; if there is one, you return back to Step (1) to fix it. The compiler will emit an error message to guide you on how to fix the error. If the source file has compiled successfully, an executable file would be generated.</li> <li>Prepare a list of test cases to cover all execution paths to examine the logic of your algorithm.</li> <li>Pick one test case and run your program. If your program outputs unexpected result (i.e., the test case is failed), which indicates a logical error, then you need to go back to Step (1). Sometimes, you may need to return back to the very beginning and revise your algorithm.</li> <li>If your program passed all test cases, then you are done.</li> </ol>"},{"location":"lectures/lec001/#debugging-and-ide","title":"Debugging and IDE","text":"<p>You, as a programmer, must test your program thoroughly, comparing the expected results to those that actually occur. When defects are found, they must be traced back to the source of the problem in the code/algorithm and corrected. The process of finding and correcting defects in a program is called debugging. Logical errors can manifest themselves in many ways, and the actual root cause might be difficult to discover.</p> <p>A software development environment is a set of tools used to create, compile, run, test, and modify a program. Some environments are referred to as integrated development environment (IDE) because they integrate various tools into one software program and provide a convenient graphical user interface (GUI). Most IDEs are shipped with a debugger tool, which helps you to debug your programs.</p> <p>Tip</p> <p>You must be familiar with this tool.</p>"},{"location":"lectures/lec001/#semantics","title":"Semantics","text":"<p>One final remark before proceeding to the next section is that writing and debugging require you to be fully aware of statements\u2019 semantics.</p> <p>Semantics of a statement</p> <p>The semantics of a statement in a programming language define what will happen when that statement is executed</p> <p>Programming languages are generally unambiguous, which means the semantics of a program are well defined. That is, there is one and only one interpretation for each statement. For example, consider the highlighted line:</p> Example<pre><code>    int length ; // define a variable of type int\n    length = 99; // What is the semantics of this statement? (1)\n</code></pre> <ol> <li>Put 99 to the object named by <code>length</code>.</li> </ol> <p>Here, as the left\u2013hand side of the assignment statement, <code>length</code> means \"the object named by <code>length</code>,\" so that the assignment statement is read \"Put 99 into the object named by <code>length</code>.\"</p>"},{"location":"lectures/lec001/#c-program-structure","title":"C++ Program Structure","text":"A typical C++ program<pre><code>// this program outputs the message \" Hello World !\" to the monitor\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// MAIN function\nint main ()\n{\n    cout &lt;&lt; \" Hello World !\" &lt;&lt; endl ;\n\n    return 0;\n}\n</code></pre>"},{"location":"lectures/lec001/#exercises","title":"Exercises","text":"<p>Exercises</p> QuestionsAnswer <ol> <li>Why are the following not comments? <pre><code>(a) /*/\n(b) /* comment? * /\n(c) // Is this\n    a comment?\n</code></pre></li> <li>What is the difference between: <pre><code>(a) #include &lt;iostream&gt;\n(b) #include &lt;iostream.h&gt;\n</code></pre></li> <li>What is the difference between: <pre><code>(a) #include &lt;string.h&gt;\n(b) #include &lt;cstring&gt;\n(c) #include &lt;string&gt;\n</code></pre></li> <li>Correct the following code without using the keywords <code>using</code> and <code>namespace</code>: <pre><code>#include &lt;iostream&gt;\nint main()\n{\n    cout &gt;&gt; \"Hello World!\" &gt;&gt; endl;\n\n    return 0;\n}\n</code></pre></li> </ol> <ol> <li> <p>(a) It should be either <code>//</code> or <code>/* */</code>. (b) There should be no space between <code>*</code> and <code>/</code> at the end. (c) <code>//</code> is a line comment. So, the second line should also begin with <code>//</code></p> </li> <li> <p>No difference. <code>&lt;iostream.h&gt;</code> is an older header file corresponding to the new header file <code>&lt;iostream&gt;</code>.</p> </li> <li> <p>(a) This is the old header name for <code>&lt;cstring&gt;</code>.      (b) This is to include C-style string library.      (c) This is to include C++ string library.</p> </li> <li>The corrected code is:     <pre><code>#include &lt;iostream&gt;\nint main()\n{\n    std.cout &gt;&gt; \"Hello World!\" &gt;&gt; std.endl;\n\n    return 0;\n}\n</code></pre></li> </ol>"},{"location":"lectures/lec001/#data-types-and-expressions","title":"Data Types and Expressions","text":"<p>Recall the following. It is important to understand and remember each definition</p> <p>Definitions</p> Type A type defines a set of possible values and a set of operations defined on them. Object An object is some memory that holds a value. Value A value is a set of bits in memory interpreted according to a type. Variable A variable is a named object. Declaration A declaration is a statement that gives a name to an object along with a type. Definition A definition is a declaration that sets aside memory for an object."},{"location":"lectures/lec001/#examples","title":"Examples","text":"<p>What is the semantics of:</p> <pre><code>int length = 100;\n</code></pre> <p> </p> <p>This is a definition statement:</p> <ol> <li>It creates a new object by allocating four-byte memory. (1)</li> <li>The new object will be named <code>length</code>.</li> <li>The data type of <code>length</code> is <code>int</code>.</li> <li>The object will be initialized with the value of 100.</li> </ol> <ol> <li>I am assuming the size of <code>int</code> is 4 bytes</li> </ol> <p>Be aware of the highlighted text above. The object will be initialized, not assigned.</p> <p>What is the semantics of:</p> <p><pre><code>length = 99;\n</code></pre> This is an assignment statement. It means to put/assign the value 99 into/to the object named by <code>length</code>.</p> <p>What is the semantics of:</p> <pre><code>int &amp;side = length;\n</code></pre> <p></p> <p>Semantically, this is a declaration statement. It means as follows. The object named by <code>length</code> has a new (another) name, which is <code>side</code>, as shown. Consequently, we have ONE object that can be referenced by two names: <code>side</code> and <code>length</code>.</p> <p>What is the semantics of:</p> <pre><code>int side = length;\n</code></pre> <p></p> <p>This is a definition statement:</p> <ol> <li>It creates a new object by allocating four-byte memory.</li> <li>The new object will be named <code>side</code>.</li> <li>The data type of <code>side</code> is <code>int</code>.</li> <li>The object will be initialized with the value of <code>length</code>.</li> </ol> <p>Self-Check</p> QuestionAnswer <p>What is the output of the following program? <pre><code>#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main() {\n    int length = 10;\n    int &amp;side = length;\n    int width = side;\n    int total = 2 * width;\n\n    side = side / 4;\n    width = width + 1;\n    total = total - 5;\n    cout &lt;&lt; \"length = \" &lt;&lt; length &lt;&lt; endl;\n    cout &lt;&lt; \"side = \" &lt;&lt; side &lt;&lt; endl; \n    cout &lt;&lt; \"width = \" &lt;&lt; width &lt;&lt; endl; \n    cout &lt;&lt; \"total = \" &lt;&lt; total &lt;&lt; endl; \n\n    return 0;\n}\n</code></pre></p> <p>Output</p> <p>length = 2  side = 2    width = 11  total = 15</p>"},{"location":"lectures/lec001/#data-types","title":"Data Types","text":"<ol> <li>Built-in data types:<ol> <li>Ordinal types: <code>int</code>, <code>char</code>.<ul> <li>C++11 signed integer types: <code>int8_t</code>, <code>int16_t</code>, <code>int32_t</code>, <code>int64_t</code>.</li> <li>C++11 unsigned integer types: <code>uint8_t</code>, <code>uint16_t</code>, <code>uint32_t</code>, <code>uint64_t</code>.</li> </ul> </li> <li>Boolean type: <code>bool</code>.</li> <li>Floating-point types: <code>float</code>, <code>double</code>.</li> <li>String type: <code>string</code></li> </ol> </li> <li>Type modifiers:<ol> <li>Sign modifiers (for ordinal types): <code>signed</code>, <code>unsigned</code>.</li> <li>Size modifiers: <code>short</code>, <code>long</code>, <code>long long</code>.</li> <li>Storage modifiers: <code>static</code>, <code>const</code>, <code>auto</code></li> </ol> </li> <li>Type specifier: <code>auto</code></li> </ol>"},{"location":"lectures/lec001/#constants-and-literals","title":"Constants and Literals","text":"<ol> <li> <p>Integer constants: </p> <ul> <li>Decimal constants (<code>int</code>): <code>3</code>, <code>-40</code> or <code>12024</code></li> <li>Binary constants (<code>int</code>): <code>0b101001011</code> or <code>0b1010'0111</code></li> <li>Octal constants (<code>int</code>): <code>023</code></li> <li>Hexadecimal constants (<code>int</code>): <code>0x1A</code> or <code>0x1a</code></li> <li>Unsigned constants: <code>123u</code>, <code>123U</code>, or <code>0xFFFFu</code></li> <li>Long constants: <code>123l</code>, <code>123L</code> or <code>0xFFFFL</code></li> <li>Unsigned long constants: <code>123ul</code>, <code>123UL</code> or <code>0xFFFFUL</code> </li> </ul> </li> <li> <p>Character constants (type is <code>char</code>)</p> <ul> <li>Letters: <code>'a'</code>, <code>'B'</code>, <code>'+'</code> or <code>' '</code></li> <li>Escape sequence: <code>'\\t'</code>, <code>'\\r'</code>, <code>'\\n'</code>, <code>'\\0'</code>, <code>'\\x20'</code> or <code>\\101</code></li> </ul> </li> <li>Floating-point constants: <code>1.2</code>, <code>2.001</code>, <code>-0.0234</code>, <code>9e-5</code> or <code>-2.34E3</code><ul> <li>No suffix defines <code>double</code></li> <li><code>f</code> or <code>F</code> defines  <code>float</code></li> <li><code>l</code> or <code>L</code> defines <code>long double</code></li> </ul> </li> <li>Boolean constants: <code>true</code>, <code>false</code>.</li> <li>Recall that literals are named constant<ol> <li>Example (1): <code>const int LENSIZE = 10;</code> Here <code>LENSIZE</code> is a constant integer with value <code>10</code>.</li> <li>Example (2): <code>constexpr double PI = 3.14159;</code></li> </ol> </li> </ol>"},{"location":"lectures/lec001/#expressions","title":"Expressions","text":"<ul> <li>The most basic building block of programs.</li> <li>An expression can be:<ol> <li>a constant,</li> <li>a variable (must have a value),</li> <li>a function call, </li> <li>an arithmetic operation, or</li> <li>a logical operation that evaluates to TRUE or FALSE</li> </ol> </li> <li>The type of an expression is the type of its value</li> </ul> <p>What is an operation?</p> <p>An operation is an expression that is composed of a set of operands and a set of operators. The operation is parsed according to the operator(s) priority and associativity. Each operand by itself is an expression.</p> <p>The expression <code>std::cout &lt;&lt; a &amp; b</code> is parsed as <code>( (std::cout &lt;&lt; a) &amp; b)</code>, and not as  <code>( std::cout &lt;&lt; (a &amp; b) )</code></p> <p>Example 1</p> <p>Consider the following expression: <code>10 + 2 / 4</code>. Simply, this expression consists of three operands (<code>10</code>, <code>2</code>, and <code>4</code>) and two operators (<code>+</code> and <code>/</code>). It will be parsed as <code>10 + (2 / 4)</code> and, eventually, evaluated as follows:</p> \\[ \\begin{align*}     10 ~~+~~ 2 ~~/~~ 4 &amp;= 10 ~~+~~ \\underbrace{2 ~~/~~ 4}_\\text{(1)} \\\\     &amp;= 10 ~~+~~ 0 \\\\     &amp;= \\underbrace{10 ~~+~~ 0}_\\text{(2)} \\\\     &amp;= 10  \\end{align*}  \\] <p>Example 2</p> <p>In these examples, we will revise the principle of  associativity .</p> <p>Consider the following expression: <code>10 / 2 / 4</code>. This expression will be parsed as <code>(10 / 2) / 4</code>. So, the evaluation will proceed as follows:</p> \\[ \\begin{align*}     10 ~~/~~ 2 ~~/~~ 4 &amp;= \\underbrace{10 ~~/~~ 2}_\\text{(1)} ~~/~~ 4 \\\\     &amp;= 5 ~~/~~ 4 \\\\     &amp;= \\underbrace{5 ~~/~~ 4}_\\text{(2)} \\\\     &amp;= 1  \\end{align*}  \\] <p>Consider the following expression: <code>x = y = 10</code>. This expression will be parsed as <code>x = (y = 10)</code> and evaluated as follows:</p> \\[ \\begin{align*}     x ~~=~~ y ~~=~~ 10 &amp;\\rightarrow x ~~=~~ \\underbrace{y ~~=~~ 10}_\\text{(1)} \\\\     &amp;\\rightarrow x ~~=~~ y \\\\     &amp;\\rightarrow \\underbrace{x ~~=~~ 10}_\\text{(2)} \\\\     &amp;\\rightarrow x \\\\     &amp;\\rightarrow 10 \\end{align*}  \\] <p>The following table shows the precedence and associativity of C++ operators (from highest to lowest precedence). Operators with the same precedence number have equal precedence unless another relationship is explicitly forced by parentheses.</p> Group Description Operator Group 1: no associativity scope resolution <code>::</code> Group 2: Naturally left to right associativity Array subscript <code>[]</code> Function call <code>()</code> Postfix increment (i.e., <code>a++</code>) <code>++</code> Postfix decrement (i.e., <code>a--</code>) <code>--</code> Type name <code>typeid</code> Constant type conversion <code>const_cast</code> Dynamic type conversion <code>dynamic_cast</code> Reinterpreted type conversion <code>reinterpret_cast</code> Static type conversion <code>static_cast</code> Group 3: Naturally right to left associativity Size of object or type <code>sizeof</code> Prefix increment (i.e., <code>++a</code>) <code>++</code> Prefix decrement (i.e., <code>--a</code>) <code>--</code> One's complement or bitwise NOT <code>~</code> Logical NOT <code>!</code> Unary negation <code>-</code> Unary plus <code>+</code> Address of <code>&amp;</code> Indirection (dereference) <code>*</code> Create object <code>new</code> <code>new[]</code> Destroy object <code>delete</code> <code>delete[]</code> C-style cast <code>()</code> Group 4: left to right associativity Pointer-to-member (objects or pointers) <code>.*</code> <code>-&gt;*</code> Group 5: left to right associativity Multiplication <code>*</code> Division <code>/</code> Modulus <code>%</code> Group 6: left to right associativity Addition <code>+</code> Subtraction <code>-</code> Group 7: left to right associativity Left shift <code>&lt;&lt;</code> Right shift <code>&gt;&gt;</code> Group 8: left to right associativity Less than <code>&lt;</code> Greater than <code>&gt;</code> Less than or equal to <code>&lt;=</code> Greater than or equal to <code>&gt;=</code> Group 9: left to right associativity Equality <code>==</code> Inequality <code>!=</code> Group 10: left to right associativity Bitwise AND <code>&amp;</code> Group 11: left to right associativity Bitwise XOR (exclusive OR) <code>^</code> Group 12: left to right associativity Bitwise OR  (inclusive OR) <code>|</code> Group 13: left to right associativity Logical AND <code>&amp;&amp;</code> Group 14: left to right associativity Logical OR <code>||</code> Group 15: right to left associativity Conditional <code>?:</code> Assignment <code>=</code> Multiplication assignment <code>*=</code> Division assignment <code>/=</code> Modulus assignment <code>%=</code> Addition assignment <code>+=</code> Subtraction assignment <code>-=</code> Left-shift assginment <code>&lt;&lt;=</code> Right-shift assignment <code>&gt;&gt;=</code> Bitwise AND assignment <code>&amp;=</code> Bitwise inclusive OR assignment <code>|=</code> Bitwise exclusive OR assignment <code>^=</code> throw expression <code>throw</code> Group 16: left to right associativity Comma <code>,</code> <p>Order of evaluation</p> <p>Consider the following expression <code>a() + b() / c()</code></p> <p>During the compile-time, <code>a()</code> will be parsed as a function call. Then, <code>b()</code> will be parsed as a function call. Then <code>c()</code> is parsed as a function call. Then, division is parsed. Finally addition is parsed. So, the compiler will produce <code>(call(a) + ( call(b) / call(c) ) )</code>.</p> <p>During the run-time, the order of function calls, <code>call(b)</code> and <code>call(c)</code>, is undetermined.  <code>call(c)</code> may be evaluated first or second. So, the order of evaluation of function calls can be:</p> <ol> <li><code>call(b)</code> \\(\\rightarrow\\) <code>call(c)</code> \\(\\rightarrow\\) <code>call(a)</code>, OR</li> <li><code>call(c)</code> \\(\\rightarrow\\) <code>call(b)</code> \\(\\rightarrow\\) <code>call(a)</code>.</li> </ol>"},{"location":"lectures/lec001/#exercises_1","title":"Exercises","text":"<p>Exercises</p> QuestionsAnswers <ol> <li> <p>What is the output of the following program? <pre><code>#include &lt;iostream&gt;\nint main() {\n    int i = 100;\n\n    i = i+i;\n    i = 2*i;\n    std::cout &lt;&lt; i+i &lt;&lt; ' ' &lt;&lt; i &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre></p> </li> <li> <p>What is the output of the following program?</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main () \n{ \n    int Ifive = 5; \n    int Isix = 6; \n    double Dfive = 5.0; \n    double Dsix = 6.0;\n\n    cout &lt;&lt; Ifive / Isix &lt;&lt; endl; \n    cout &lt;&lt; Dfive / Dsix &lt;&lt; endl;\n    cout &lt;&lt; Ifive / Dsix &lt;&lt; endl;\n    cout &lt;&lt; Dfive / Isix &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> </li> <li> <p>The following fragment purports to convert from degrees Celsius to degrees Fahrenheit. However, it has an error. Fix the code. <pre><code>double c = 20;\ndouble f;\n\nf = (9/5) * c + 32.0;\ncout &lt;&lt; c &lt;&lt; \"C is equivalent to \" &lt;&lt; f &lt;&lt; \"F.\" &lt;&lt; endl;\n</code></pre></p> </li> <li> <p>Find the syntax errors in the following program and fix them, so that the program runs and displays <code>Nice</code>. <pre><code>#include &lt;iostream&gt;\nint main()\n{\n    int j = 4.5;\n    unsigned float i = 1.23;\n    double j = 6.7;\n\n    k = 10;\n    cout &lt;&lt; \"Nice &lt;&lt; '\\n';\n    return 5;\n}\n</code></pre></p> </li> <li> <p>Is there an error in the following code segment? (What kind? syntactic or semantic), assume <code>x</code> is declared as <code>int</code>: <pre><code>// check if x between 1 and 10\nif (1 &lt;= x &lt;= 10)\n    cout &lt;&lt; \"Correct\" &lt;&lt; endl;\nelse\n    cout &lt;&lt; \"Incorrect\" &lt;&lt; endl;\n</code></pre></p> </li> <li> <p>What is the output of the following program? <pre><code>#include &lt;iostream&gt;\nint main() \n{\n    int k;\n    float i = 3.9, j = 1.2;\n\n    k = i + (int)j;\n    std::cout &lt;&lt; k - (int)((int)i + j) &lt;&lt; '\\n';\n    return 0;   \n}\n</code></pre></p> </li> <li> <p>The following program reads three integers and displays their average. Is it written correctly? <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main() \n{\n    int i, j, k;\n\n    cout &lt;&lt; \"Enter three integers: \";\n    cin &gt;&gt; i &gt;&gt; j &gt;&gt; k;\n    cout &lt;&lt; fixed &lt;&lt; \"Avg: \" &lt;&lt; i+j+k / 3 &lt;&lt; endl;\n    return 0;       \n}\n</code></pre></p> </li> <li> <p>What is the output of the following program? Note: There is no syntactic error.     <pre><code>#include &lt;iostream&gt;\nint main()\n{\n    int a = 4, b = 6, c;\n    a = (a &lt;= (b-2)) + (b &gt; (a+1));\n    b = (a == 2) &gt; ((b-3) &lt; 3);\n    c = (b != 0);\n    std::cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; ' ' &lt;&lt; c &lt;&lt; '\\n';\n    return 0;\n}\n</code></pre></p> </li> </ol> <ol> <li>Check the answer by yourself (write and run)</li> <li>Write and run the code</li> <li>There is a logical error at <code>9/5</code>, which always produces integer <code>1</code>. The code should be     <pre><code>double c = 20;\ndouble f;\n\nf = (9.0/5) * c + 32.0;\ncout &lt;&lt; c &lt;&lt; \"C is equivalent to \" &lt;&lt; f &lt;&lt; \"F.\" &lt;&lt; endl;\n</code></pre></li> <li> <pre><code>#include &lt;iostream&gt;\nint main()\n{\n    float i = 1.23;\n    double j = 6.7;\n\n    int k = 10;\n    std::cout &lt;&lt; \"Nice &lt;&lt; '\\n';\n    return 5;\n}\n</code></pre> </li> <li> <p>Yes!. There is a semantic error. The conditional expression will be parsed as <code>( (1 &lt;= x) &lt;= 10)</code>. Regardless of the value of <code>x</code>, the conditional expression is always TRUE. The correct way to express that \\(x\\) between 1 and 10 is</p> <pre><code>if ((1 &lt;= x) &amp;&amp; (x &lt;= 10))\n    cout &lt;&lt; \"Correct\" &lt;&lt; endl;\nelse\n    cout &lt;&lt; \"Incorrect\" &lt;&lt; endl;\n</code></pre> </li> <li> <p>Write and run by yourself</p> </li> <li>No, there is a logical error. The expression <code>i+j+k / 3</code> will be parsed as <code>( (i + j) + (k / 3) ). So the last</code>cout` should be:     <pre><code>cout &lt;&lt; fixed &lt;&lt; \"Avg: &lt;&lt; (i + j + k)/3 &lt;&lt; endl;\n</code></pre></li> <li>Write and run by yourself</li> </ol>"},{"location":"lectures/lec001/#scope-and-lifetime","title":"Scope and Lifetime","text":"<ul> <li> <p>In a nutshell, the term scope is associated with variables, while lifetime (sometimes we say storage duration) is associated with objects. A variable could have a local scope or global scope. Similarly, an object could have a local lifetime or global lifetime. Consider the following illustrative example:</p> <pre><code>int days;\n\nint main() \n{\n    int week = 1;\n    .\n    .\n}\n\nvoid myfunc (int t)\n{\n    int month;\n    static int next = 0;\n    .\n    .\n}\n</code></pre> </li> <li> <p>The variable <code>days</code> has a global scope. So, the name is visible from line 1 up to line 16.</p> </li> <li>The object referenced by <code>days</code> has a global lifetime. So, the object's life starts when the program starts executing and ends when the program terminates. In other words, the object will be created (or constructed) when the program starts and destroyed when the program terminates.</li> <li>The variable <code>week</code> is visible only within its block (i.e., from line 5 up to line 8). The life of the object referenced by <code>week</code> starts when the program executes line 5 and ends when the execution reaches line 8.</li> <li>The variable <code>t</code> is visible within the function block (i.e., from line 11 up to line 16). The life of the object referenced by <code>t</code> starts whenever the program invokes the function <code>myfunc</code> and ends when the function returns.</li> <li>The variable <code>month</code> is visible only within its block (i.e., from line 12 up to line 16). The life of the object referenced by <code>month</code> starts whenever the program executes line 12 and ends when the function returns.</li> <li>The variable <code>next</code> has a local scope (i.e., it's visible from line 13 up to line 16). However, the object referenced by <code>next</code> has a global lifetime, due to the keyword <code>static</code>. This implies that the object will be created ONLY ONCE, when the program executes the function for the first time. The object will be destroyed when the program terminates.</li> </ul> <p>Self-Check</p> QuestionAnswer <p>What is the output of the following program?</p> <pre><code>    #include &lt;iostream&gt;\n    using namespace std;\n    void myfunc () {\n        int x = 5;\n        static int y = 5;\n\n        cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; \", y = \" &lt;&lt; y &lt;&lt; endl;\n        x = x + 1;\n        y = y + 1;\n        return;\n    }\n    int main()\n    {\n        myfunc();       // first call\n        myfunc();       // second call\n        myfunc();       // third call\n    }\n</code></pre> <p>Output</p> <p>x = 5, y = 5  x = 5, y = 6  x = 5, y = 7</p>"},{"location":"lectures/lec001/#lvalue-and-rvalue","title":"Lvalue and Rvalue","text":"<ul> <li> <p>One of the fundamental C++ concepts is the concept of value category, which we are going to explain it very briefly.</p> </li> <li> <p>Every C++ expression has a type, and belongs to a value category. The value categories are the basis for rules that compilers must follow when creating, copying, and moving temporary objects during expression evaluation.</p> </li> <li> <p>In this course, we focuses on two value categories: Lvalue and Rvalue.</p> <ul> <li>Lvalue is an expression whose evaluation determines the identity of an object</li> <li>Rvalue is an expression whose evaluation:<ul> <li>computes the value of an operand of a built-in operator (such rvalue has no result object), or</li> <li>initializes an object (such rvalue is said to have a result object).</li> </ul> </li> </ul> </li> <li> <p>The following table shows some expressions that are either lvalue or rvalue.</p> Lvalue Rvalue Variable name Literals <code>a = b</code>, <code>a += b</code>, <code>a %= b</code>, and all other built-in assignment expressions function calls whose return type is non-reference <code>++a</code> and <code>--a</code> <code>a++</code> and <code>a--</code> <code>*p</code> <code>&amp;a</code> <code>a[n]</code> all built-in arithmetic and logical expressions </li> </ul> <p>The assignment statement</p> <p>The left-hande side of an assignment is always treated as lvalue and the right-hand side is treated as rvalue.</p> <p>Example 1</p> <pre><code>    x = y;\n</code></pre> <ul> <li>The right-hand expression, which is <code>y</code>, will be treated as rvalue. The left-hand expression, which is <code>x</code>, will be treated as lvalue. </li> <li>The rvalue of <code>y</code> is its content (or the value of <code>y</code>). The lvalue of <code>x</code> is its memory location or the object referenced by <code>x</code>.</li> <li>Consequently, the meaning (or semantics) of this statement is as follows: Put the value of <code>y</code> into the object named by <code>x</code>.</li> </ul> <p>Example 2</p> <pre><code>    x + 1 = y;\n</code></pre> <p>If you try to compile the above statement, the compiler will throw an error message: </p> <p><code>lvalue required as left operand of assignment.</code></p> <p>Because the expression <code>x + 1</code> can't be an lvalue. No memory location associated with this expression. </p> <p>Example 3</p> <pre><code>    ((x &lt; 5)? x : y) = 10;\n</code></pre> <p>The left-hand side, which is the conditional operator, is a valid lvalue expression, since its lvalue is either the memory location of <code>x</code> or the memory location of <code>y</code>. The right-hand side, which is <code>10</code>, is a valid rvalue. The conditional operator has the inner expression <code>(x &lt; 5)</code>, where <code>x</code> will be treated as rvalue. Therefore, the semantics is as follows. If the value of <code>x</code> is less than <code>5</code>, put the value <code>10</code> into <code>x</code>. Otherwise, put the value <code>10</code> into <code>y</code>.</p>"},{"location":"lectures/lec001/#initialization-and-assignment","title":"Initialization and Assignment","text":"<ul> <li> <p>You need to distinguish two similar, but logically distinct, operations:</p> <ul> <li>Initialization (giving a variable its initial value at the time of construction)</li> <li>Assignment (giving a variable a new value)</li> </ul> </li> <li> <p>These operations are so similar that C++ allows us to use the same notation (the <code>=</code> operator) for both. </p> </li> <li> <p>Let us consider the following code:     <pre><code>int length = 99;        // definition statement\nint width;\n\nwidth = 10;             // assignment statement\n</code></pre></p> <p>There is no doubt that the operator <code>=</code>, in line 4, is the assignment operator. It puts the value 10 into the object named by <code>width</code>. However, the operator <code>=</code>, in line 1, is NOT the assignment operator. The form <code>= 99</code> is known as an initializer. It means that as part of constructing the object named by <code>length</code>, the value <code>99</code> will be inserted, such that after the construction finishes, the variable <code>length</code> will have the initial value <code>99</code>. </p> </li> <li> <p>In C++, the initializer may be one of the following forms:</p> <ol> <li><code>(</code> expression-list <code>)</code></li> <li><code>=</code> expression</li> <li><code>{</code> initializer-list <code>}</code></li> <li><code>{</code> designated-initializer-list<code>}</code></li> </ol> </li> <li> <p>Therefore, initialization can be written as follows:</p> <ul> <li><code>int length = 99; // using the second form</code> or</li> <li><code>int length (99); // using the first form</code> or</li> <li><code>int length {99}; // using the third form</code></li> </ul> </li> </ul> <p>Important</p> <ul> <li>When declaring a reference variable, such as <code>int &amp;side = length</code>, the initializer must be an lvalue. </li> <li>The initialization operation occurs at the time of object's construction. It also takes place during function calls: function parametrs and the function returns values are also initialized.</li> </ul>"},{"location":"lectures/lec001/#exercises_2","title":"Exercises","text":"<p>Exercises</p> QuestionsAnswers <ol> <li> <p>Write a program that declares two floating-point variables (e.g., <code>a</code>, <code>b</code>), assigns to them two positive values (e.g., <code>3.45</code> and <code>6.78</code>) and swaps their integer parts (i.e., <code>a</code> becomes <code>6.45</code> and <code>b</code> becomes <code>3.78</code>). For casting, use the <code>static_cast&lt;&gt;</code> operator.</p> </li> <li> <p>Write a program that reads three integers, stores them in three variables, and rotates them one place right. For example, if the user enters the numbers <code>1</code>, <code>2</code>, and <code>3</code> and they are stored in variables <code>a1</code>, <code>a2</code> and <code>a3</code>, the program should rotate their values one place right, so that <code>a1</code> becomes <code>3</code>, <code>a2</code> becomes <code>1</code>, and <code>a3</code> becomes <code>2</code>.</p> </li> <li> <p>Write a program that reads a three-digit positive integer, makes its hundreds ones and vice versa and displays the new number. For example, if the user enters <code>123</code>, the program should display <code>321</code>. Use only one variable.</p> </li> <li> <p>Write a program that reads a positive integer and rounds it up or down to its nearest tens. For example, if the user enters <code>13</code>, the program should display <code>10</code>. if the input number is <code>6</code>, the program should display <code>10</code>, while if it is <code>255</code>, the program should display <code>260</code>. For casting, use the <code>static_cast&lt;&gt;</code> operator.</p> </li> </ol> <ol> <li> <p>Click here to see the logical thinking.</p> <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    float a = 3.45, b = 6.78;\n    double dec;\n\n    int temp = static_cast&lt;int&gt;(a); // store integer part of a\n    dec = a - static_cast&lt;int&gt;(a);  // decimal part of a\n    a = static_cast&lt;int&gt;(b) + dec;\n    dec = b - static_cast&lt;int&gt;(b);  // decimal part of b\n    b = temp + dec;\n\n    std::cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \", b = \" &lt;&lt; b &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> </li> <li> <p>Click here to see the logical thinking</p> <pre><code>#include &lt;iostream&gt;\n\nint main() \n{\n    int a1, a2, a3;\n\n    std::cout &lt;&lt; \"Enter three integers (a1, a2 and a3): \";\n    std::cin &gt;&gt; a1 &gt;&gt; a2 &gt;&gt; a3;\n\n    int temp = a3;\n    a3 = a2;\n    a2 = a1;\n    a1 = temp;\n\n    std::cout &lt;&lt; \"a1 = \" &lt;&lt; a1 &lt;&lt; \", a2 = \" &lt;&lt; a2 &lt;&lt; \", a3 = \" &lt;&lt; a3 &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> </li> <li> <p>Click here to see the logical thinking</p> <pre><code>#include &lt;iostream&gt;\nusing std::cout;\nusing std::cin;\nusing std::endl;\n\nint main()\n{\n    int n;\n\n    cout &lt;&lt; \"Enter three-digit positive integer: \";\n    cin &gt;&gt; n;\n\n    n = n/100 + ((n/10) % 10)*10 + (n%10)*100;\n\n    cout &lt;&lt; \"The output is \" &lt;&lt; n &lt;&lt; endl;\n    return 0;\n}\n</code></pre> </li> <li> <p>Think logically by yourself on how to find the nearest tens. Solve some examples manually to infer the steps</p> <pre><code>#include &lt;iostream&gt;\n\nint main() \n{\n    int n;\n    std::cout &lt;&lt; \"Enter postive number: \";\n    std::cin &gt;&gt; n;\n\n    float m = (n + 5) / 10.0;\n    n = static_cast&lt;int&gt;(m) * 10;\n\n    std::cout &lt;&lt; \"The number after rounding to nearest 10: \" &lt;&lt; n &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre> </li> </ol>"},{"location":"lectures/lec002/","title":"Lecture 0: Review - Part 2","text":""},{"location":"lectures/lec002/#compound-statement","title":"Compound Statement","text":"<ul> <li>A compound statement (also known as a block) is a collection of multiple statements enclosed within curly braces <code>{</code> <code>}</code>, executed together as if they were a single statement. </li> <li>They can be used in any context where a single statement is allowed.</li> <li>It typically appears as the body of another statement, such as: <code>if</code> statement or <code>for</code> statement.</li> <li>The following example shows two compound statements, which are highlighted:</li> </ul> Example<pre><code>#include &lt;iostream&gt;\nint main()\n{\n    int a = 10;     // definition statement\n    { // this is a compound statement\n        int b = 6;\n        std::cout &lt;&lt; \"a+b = \" &lt;&lt; a+b &lt;&lt; '\\n';\n    }\n    a = a + 1;      // assignment statement\n    { // this is another compound statement\n        int b = 4;\n        std::cout &lt;&lt; \"a+b = \" &lt;&lt; a+b &lt;&lt; '\\n';\n    }\n    return 0;       // return statement\n}\n</code></pre> <ul> <li>In the above exmple, the <code>main</code> function has FIVE statements: definition statement, compound statement, assignment statement, compound statement, and return statement.</li> <li>Notice that the variable <code>b</code> is only visible within its block.</li> </ul>"},{"location":"lectures/lec002/#branching","title":"Branching","text":"<ul> <li>A branch is a statement in a program that can cause a CPU to begin executing a different statement sequence and thus deviate from its default behavior of executing statements in order (i.e., sequentially).</li> <li>Branching transfers the control to execute a statement that is not the next statement. Usually, we describe this transfer as jump.</li> </ul>"},{"location":"lectures/lec002/#types-of-branching-in-c","title":"Types of branching in C++","text":""},{"location":"lectures/lec002/#conditional-branching","title":"Conditional branching","text":"<ol> <li><code>if</code> statement</li> <li><code>if else</code> statement</li> <li><code>switch</code> statement</li> <li><code>while</code> statement</li> <li><code>do while</code> statement</li> <li><code>for</code> statement</li> </ol>"},{"location":"lectures/lec002/#unconditional-branching","title":"Unconditional branching","text":"<ol> <li><code>break</code> statement</li> <li><code>continue</code> statement</li> <li><code>goto</code> statement</li> </ol>"},{"location":"lectures/lec002/#examples","title":"Examples","text":"<p>What will the following program display?</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nint main ()\n{\n    int a = 0, b = 2, x = 4, y = 0;\n    cout &lt;&lt; ((a == b) || (a == y)) &lt;&lt; endl;\n    cout &lt;&lt; (2*b != x) &lt;&lt; endl;\n    cout &lt;&lt; ((b &lt;= x) &amp;&amp; (b &gt; a)) &lt;&lt; endl;\n    cout &lt;&lt; (y &gt; a) &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Output</p> <p>1  0  1  0 </p> <p>What is the semantics of the following code?</p> <pre><code>if (sales &gt; 10000)\n    balance += 2000;\nstd::cout &lt;&lt; \"Balance: \" &lt;&lt; balance &lt;&lt; std::endl;\n</code></pre> <p></p> <p>First, increase the balance by two thousands only if the value of <code>sales</code> is larger than ten thousands. Second, print the value of <code>balance</code>. The semantics is illustrated in the shown figure. </p> <p>The arrows represent \"transfer of control\". When the control at <code>if</code> statement, it evaluates the boolean expression. If the boolean expression is true, the control will transfer to execute <code>balance+=2000;</code> and then <code>cout &lt;&lt; balance</code>. If the boolean expression is false, the control will transfer to <code>cout &lt;&lt; balance</code>.  </p> <p>Tip</p> <p>You should be familiar with the transfer of control for each branching statement.</p> <p>What is the semantics of the following code?</p> <pre><code>int number = 0;\nwhile (number &lt; 5) {\n    cout &lt;&lt; \"Hello!\" &lt;&lt; endl;\n    number = number + 1;\n}\n</code></pre> <p></p> <p>This code will print out \"Hello!\" five times. The semantics of <code>while</code> loop is illustrated in the shown figure.</p> <p>Did you see a loop? <code>while</code>, <code>do-while</code> and <code>for</code> are known as loop statements.</p> <p>Express the following logic using C++</p> <p>Print the message \u201cThe number is valid\u201d if the variable <code>speed</code> is within the range 0 through 200.</p> <p>The C++ code is: <pre><code>if (speed &gt;= 0 &amp;&amp; speed &lt;= 200)\n    std::cout &lt;&lt; \"The number is valid\\n\";\n</code></pre></p> <p>Express the following logic using C++</p> <p>Assign 0.10 to <code>commissionRate</code> unless sales is greater than or equal to 50000.00, in which case it assigns 0.20 to <code>commissionRate</code></p> <p>The code is: <pre><code>if (sales &lt; 50000.00)\n    commissionRate = 0.10;\nelse\n    commissionRate = 0.20;\n</code></pre></p> <p>or <pre><code>if (sales &gt;= 50000.00)\n    commissionRate = 0.20;\nelse\n    commissionRate = 0.10;\n</code></pre></p> <p>Express the following logic using C++</p> <p>We need the sum of all numbers between 0 and 1000 that are divisible by 3.</p> <p>The C++ code is: <pre><code>int sum = 0;\nfor (int n=3; n&lt;=1000; n+=3)\n    sum += n;\nstd::cout &lt;&lt; \"Sum = \" &lt;&lt; sum &lt;&lt; std::endl;\n</code></pre></p> <p>Another acceptable answer: <pre><code>int sum = 0;\nfor (int i=0; i&lt;=1000; i++)\n    if (i%3 == 0)\n        sum += i;\nstd::cout &lt;&lt; \"Sum = \" &lt;&lt; sum &lt;&lt; std::endl;\n</code></pre></p> <p>Notice the following:</p> <p></p> <ul> <li> <p>In the second solution, the <code>for</code> loop has ONE inner statement to repeat, which is <code>if</code> statement, and <code>if</code> statement has also ONE inner statement, which is <code>sum += i;</code>. </p> </li> <li> <p>We can write the inner statements as compound statements:     <pre><code>for (int i=0; i&lt;=1000; i++) {\n    if (i%3 == 0) {\n        sum += i;\n    }\n}\n</code></pre>     But these braces are redundant, since all compound statements consist of only ONE statement.</p> </li> <li> <p>The semantics of this <code>for</code> loop is illustrated in the shown figure.</p> </li> </ul> <p>Express the following logic using C++</p> <p>Suppose x and y are variables of type <code>int</code> that have been given values. Write an if-else statement that increases the value of x by 10 if x is greater than y. Otherwise, it sets the value of y to zero and decreases the value of x by 1.</p> <p>The C++ code is:</p> <pre><code>if (x &gt; y)\n    x = x + 10;\nelse {\n    x = x - 1;\n    y = 0;\n}\n</code></pre> <p>Express the following logic using C++</p> <p>Suppose you are writing a database system where you store the result of a transaction in a variable named <code>result</code> of type <code>int</code>. Write a switch statement that outputs the status of the transaction. It should output the message \"transaction is completed\" if the result is equal to one. The transaction is still processing if the result is zero. However, if the result is -1, it means the transaction has failed.</p> <p>The C++ code is</p> <pre><code>switch (result)\n{\ncase 1:\n    cout &lt;&lt; \"Transaction is completed.\" &lt;&lt; endl;\n    break;\ncase 0:\n    cout &lt;&lt; \"Transaction is still processing.\" &lt;&lt; endl;\n    break;\ncase -1:\n    cout &lt;&lt; \"Trasaction has failed.\" &lt;&lt; endl;\n    break;\ndefault:\n    cout &lt;&lt; \"Unknown status.\" &lt;&lt; endl;\n}\n</code></pre> <p>Write a code</p> <p>Suppose a, b and c are variables of type <code>int</code> that have been given values. Write a code to display the smallest value.</p> <p>The code is: <pre><code>cout &lt;&lt; \"The smallest is \";\nif (a &lt; b &amp;&amp; a &lt; c)\n    cout &lt;&lt; a;\nelse if (b &lt; c)\n    cout &lt;&lt; b;\nelse\n    cout &lt;&lt; c;\ncout &lt;&lt; endl;\n</code></pre></p> <p>Another (not recommended but acceptable) solution: <pre><code>cout &lt;&lt; \"The smallest is \";\nif (a &lt; b)\n    if (a &lt; c)\n        cout &lt;&lt; a;\n    else\n        cout &lt;&lt; c;\nelse\n    if (b &lt; c)\n        cout &lt;&lt; b;\n    else\n        cout &lt;&lt; c;\ncout &lt;&lt; endl;\n</code></pre></p> <p>Another solution: <pre><code>int smallest = a;\nif (b &lt; smallest) smallest = b;\nif (c &lt; smallest) smallest = c;\ncout &lt;&lt; \"The smallest is \" &lt;&lt; smallest &lt;&lt; endl;\n</code></pre></p> <p>Write a Program</p> <p>Write a C++ program that reads two floats (e.g., <code>a</code> and <code>b</code>) and displays the solution of the equation \\(ax + b = 0\\), if any.</p> <p>The logical thinking of this problem is as follows:</p> <ol> <li>INPUT: two numbers <code>a</code> &amp; <code>b</code>.</li> <li>PROCESS: compute the value of <code>x</code>, where \\(x = -b/a\\). We need to be careful when <code>a</code> is zero.</li> <li>OUTPUT: the value of <code>x</code>.</li> </ol> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    float a, b;\n    cout &lt;&lt; \"This program solves the equation ax + b = 0\" &lt;&lt; endl;\n    cout &lt;&lt; \"-------------------------------------------\\n\\n\";\n    cout &lt;&lt; \"Enter the value of a: \"; cin &gt;&gt; a;\n    cout &lt;&lt; \"Enter the value of b: \"; cin &gt;&gt; b;\n\n    if (a == 0)\n        cout &lt;&lt; \"No equation!\\n\";\n    else {\n        float x = -b/a;\n        cout &lt;&lt; \"The solution is x = \" &lt;&lt; fixed &lt;&lt; x &lt;&lt; endl;\n    }\n\n    return 0;\n}\n</code></pre> <p>Write a Program</p> <p>Write a program that reads two integers and displays the sum of the integers between them. For example, if the user enters \\(5\\) and \\(9\\), the program would display \\(21\\) because \\(6+7+8=21\\). The program should check which one of the two numbers is the greater and act accordingly.</p> <p>The logical thinking of this program:</p> <ol> <li>INPUT: two integer numbers <code>a</code> and <code>b</code></li> <li>PROCESS:<ol> <li>If <code>b</code> is less than <code>a</code>, then swap the values; so that <code>a</code> is less than or equal to <code>b</code></li> <li>Define a variable <code>sum</code> and initialize it to <code>0</code>.</li> <li>Start a for loop from a+1 up to b-1<ol> <li>In each iteration, add the value of loop index to sum</li> </ol> </li> </ol> </li> <li>OUTPUT: the value of sum.</li> </ol> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int a, b;     // the two numbers\n\n    cout &lt;&lt; \"Enter two numbers: \";\n    cin &gt;&gt; a &gt;&gt; b;\n\n    // make sure that a is less than or equal to b\n    if (b &lt; a) {\n        // do swapping\n        int temp = b;\n        b = a;\n        a = temp;\n    }\n\n    int sum = 0;\n    for (int i=a+1; i&lt;b; i++) // or i &lt;= b-1\n        sum += i;\n\n    cout &lt;&lt; \"Sum = \" &lt;&lt; sum &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>Write a Program</p> <p>In mathematics, a number \\(n\\) is said to be perfect if it equals to the sum of its proper divisors, deficient if the sum of its proper divisors is less than \\(n\\), and abundant if this sum exceeds \\(n\\).</p> <p>For example, \\(6\\) is a perfect number since its proper divisors are \\(1\\), \\(2\\) and \\(3\\), and their sum is \\(6\\). \\(12\\) is abundant becuase the sum of its proper divisors is \\(1+2+3+4+6 = 16\\).</p> <p>Write a program that reads a positive number and determines whether the number is perfect, deficient or abundant.</p> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int n;  // the number variable\n\n    cout &lt;&lt; \"Enter a number n: \";\n    cin &gt;&gt; n;\n\n    // check if n is negative\n    if (n&lt;0) {\n        cout &lt;&lt; \"Enter a positive number\" &lt;&lt; endl;\n        return 0;\n    }\n    int sum = 0; // to store the sum of divisors\n    // we iterate from 1 up to n/2\n    // or we iterate from n/2 down to 1\n    for (int d=n/2; d&gt;=1; d--)\n        if (n % d == 0) // if d is a divisor\n            sum += d;   // add d to sum\n\n    // output the result        \n    if (sum == n) // perfect\n        cout &lt;&lt; n &lt;&lt; \" is a perfect number.\" &lt;&lt; endl;\n    else if (sum &lt; n) // deficient\n        cout &lt;&lt; n &lt;&lt; \" is a deficient number.\" &lt;&lt; endl;\n    else // abundant\n        cout &lt;&lt; n &lt;&lt; \" is an abundant number.\" &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"lectures/lec002/#exercise","title":"Exercise","text":"<p>Exercise</p> <p>You have four identical prizes to give away and a pool of 25 finalists. The finalists are assigned numbers from 1 to 25. Write a program to randomly select the numbers of 4 finalists to receive a prize. Make sure not to pick the same number twice. For example, picking finalists 3, 15, 22, and 14 would be  valid but picking 3, 3, 31, and 17 would be invalid, because finalist number 3 is listed twice and 31 is not a valid finalist number</p>"},{"location":"lectures/lec002/#functions","title":"Functions","text":""},{"location":"lectures/lec002/#basic-concepts","title":"Basic Concepts","text":"<ul> <li>Recall that there are two kinds of functions in C++: functions that return (produce) a value and functions that do not return a value. Functions that do not return a value are called void functions.</li> <li>For a function that returns a value, a function call is an expression consisting of the function name followed by arguments enclosed in parentheses. If there is more than one argument, the arguments are separated by commas.</li> <li>For a void function, a function call (function invocation) is a statement consisting of the function name followed by arguments enclosed in parentheses and then terminated with a semicolon.</li> <li>Similar to variable declaration and variable definition, we also have function declaration and function definition. </li> <li>A function declaration (or function prototype) consists of, in order: <ol> <li>the type of the value returned by the function; if the function has no return value, the type shall be <code>void</code>,</li> <li>the name of the function,</li> <li>a list of formal parameters (or simply parameters), and</li> <li>a semicolon (<code>;</code>).</li> </ol> </li> <li>A function definition consists of a function header followed by a function body. The function header is written similar to the function declaration, except that the header does not have a semicolon at the end. The value returned is determined by the statements in the function body.</li> <li>In function prototype, it is not necessary to list the name of the parameter inside the parentheses. Only  its data type is required. The compiler ignores the name of the parameter variable in the function prototype.</li> </ul> <p>Example: The smallest number</p> <p>The following program takes three integer numbers as input from a user, and prints the smallest.</p> <pre><code>#include &lt;iostream&gt;\n\n// function prototype\nint getSmallValue (int, int);\n\nint main()\n{\n    int n1, n2, n3; // three integer numbers\n\n    std::cout &lt;&lt; \"Enter three numbers: \";\n    std::cin &gt;&gt; n1 &gt;&gt; n2 &gt;&gt; n3;\n\n    int smallest = getSmallValue(n1, n2); // invoke getSmallValue()\n    smallest = getSmallValue(smallest, n3);\n\n    std::cout &lt;&lt; \"The smallest value is \" &lt;&lt; smallest &lt;&lt; std::endl;\n    return 0;\n}\n\n// function definition\nint getSmallValue(int a, int b)\n{\n    return ((a&lt;b)? a : b);\n}\n</code></pre> <p>In the previous example, we can actually print out the minimum value without defining a new variable. So, the following code: <pre><code>int smallest = getSmallValue(n1, n2); // invoke getSmallValue()\nsmallest = getSmallValue(smallest, n3);\n\nstd::cout &lt;&lt; \"The smallest value is \" &lt;&lt; smallest &lt;&lt; std::endl;\n</code></pre> can be replaced by: <pre><code>std::cout   &lt;&lt; \"The smallest value is \"\n            &lt;&lt; getSmallValue(getSmallValue(n1, n2), n3)\n            &lt;&lt; std::endl;\n</code></pre></p> <p>Example: Perfect, deficient or abundant</p> <p>The following program reads a positive number and determines whether the number is perfect, deficient or abundant.</p> <pre><code>#include &lt;iostream&gt;\n\n// function prototype\nint sumOfProperFactors(int number);\n\nint main()\n{\n    int num;\n    std::cout &lt;&lt; \"Enter a positive number: \";\n    std::cin &gt;&gt; num;\n\n    if (int sum = sumOfProperFactors(num); sum == num)\n        std::cout &lt;&lt; num &lt;&lt; \" is a perfect number\\n\";\n    else if (sum &gt; num)\n        std::cout &lt;&lt; num &lt;&lt; \" is a abundant number\\n\";\n    else\n        std::cout &lt;&lt; num &lt;&lt; \" is a deficient number\\n\";\n\n    return 0;    \n}\n\n// function definition\nint sumOfProperFactors(int n)\n{\n    int sum = 1;\n    for (int d=n/2; d&gt;1; d--)\n        if (n % d == 0)\n            sum += d;\n    return sum;\n}\n</code></pre> <p>Rolling a Pair of Dice</p> <p>In this example, we write a function that rolls a pair of dice until the sum of the numbers rolled is a specific number. We also want to know the number of times the dice are rolled to get the desired sum.</p> <p>The smallest number on each die is 1, and the largest number is 6. So the smallest sum of the numbers rolled is 2, and the largest sum of the numbers rolled is 12. Suppose that we have the following declarations: <pre><code>int die1;\nint die2;\nint sum;\nint rollCount = 0;\n</code></pre></p> <p>We use the random number generator <code>rand()</code> to randomly generate a number between 1 and 6. Then, the following statement randomly generates a number between 1 and 6 and stores that number into <code>die1</code>, which becomes the number rolled by die1 <pre><code>die1 = rand() % 6 + 1;\n</code></pre></p> <p>Similarly, the following statement randomly generates a number between 1 and 6 and stores that number into <code>die2</code>, which becomes the number rolled by die2. <pre><code>die2 = rand() % 6 + 1;\n</code></pre></p> <p>The sum of the numbers rolled by two dice is: <pre><code>sum = die1 + die2;\n</code></pre> We can now write the function <code>rollDice()</code> that takes as a parameter the desired sum of the numbers to be rolled and returns the number of times the dice are rolled to roll the desired sum. <pre><code>int rollDice(int desiredSum)\n{ \n    int die1;\n    int die2;\n    int sum;\n    int rollCount = 0;\n\n    srand(time(0));\n\n    do {\n        die1 = rand() % 6 + 1;\n        die2 = rand() % 6 + 1;\n        sum = die1 + die2;\n        rollCount++;\n    } while (sum != desiredSum);\n\n    return rollCount;\n}\n</code></pre></p> <p>Self-Check</p> QuestionsAnswers <ol> <li> <p>What is the semantics of the following line? <pre><code>bool flag(double r);\n</code></pre></p> </li> <li> <p>The following program has some syntax errors. Find these errors and then correct them? <pre><code>#include &lt;iostream&gt;\n\nint main() \n{\n    std::cout &lt;&lt; \"Sum = \" &lt;&lt; sum(3, 5) &lt;&lt; std::endl;\n    return 0;\n}\nint sum (int a, int b);\n{\n    return a+b;\n}\n</code></pre></p> </li> <li> <p>Write a function declaration and a function definition for a function that takes one argument of type double. The function returns the character value \u2019P\u2019 if its argument is positive and returns \u2019N\u2019 if its argument is zero or negative.</p> </li> <li> <p>Write a function definition for a function called <code>inOrder</code> that takes three arguments of type <code>int</code>. The function returns <code>true</code> if the three arguments are in ascending order; otherwise, it returns <code>false</code>. For exmaple, inOrder (1 , 2 , 3) and inOrder (1 , 2 , 2) both return true, whereas inOrder (1 , 3 , 2) returns false.</p> </li> </ol> <ol> <li> <p>This is a function prototype, for which it declares <code>flag</code> as a function that accepts one parameter of type double and returns a boolean value.</p> </li> <li> <p>There are two syntax errors:</p> <p>a. The function header ends with semicolor.</p> <p>b. In <code>main()</code> function, the identifier <code>sum</code> is not declared.</p> <p>There are two solutions. The first solution is: <pre><code>#include &lt;iostream&gt;\n\nint sum (int a, int b);\n\nint main() \n{\n    std::cout &lt;&lt; \"Sum = \" &lt;&lt; sum(3, 5) &lt;&lt; std::endl;\n    return 0;\n}\nint sum (int a, int b)\n{\n    return a+b;\n}\n</code></pre></p> <p>The second solution is: <pre><code>#include &lt;iostream&gt;\n\nint sum (int a, int b)\n{\n    return a+b;\n}                \nint main() \n{\n    std::cout &lt;&lt; \"Sum = \" &lt;&lt; sum(3, 5) &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre></p> </li> <li> <pre><code>// function declaration\nchar checkNumber (double);\n\n// function definition\nchar checkNumber (double v)\n{\n    if (v&gt;0)\n        return 'P';\n    else\n        return 'N';\n}\n</code></pre> <p>Another function definition: <pre><code>// function definition\nchar checkNumber (double v)\n{\n    return ((v&gt;0)? 'P': 'N');\n}\n</code></pre></p> </li> <li> <pre><code>bool inOrder (int a1, int a2, int a3)\n{\n    if (a1 &lt;= a2 &amp;&amp; a2 &lt;= a3)\n        return true;\n    else\n        return false;\n}\n</code></pre> <p>Another solution:  <pre><code>// let's find inOrder for two numbers\nbool inOrder (int a, int b)\n{\n    return (a &lt;= b);\n}\n\n// Then, we can find inOrder for three numbers as follows:\nbool inOrder (int a1, int a2, int a3)\n{\n    return inOrder(a1, a2) &amp;&amp; inOrder(a2, a3);\n}\n</code></pre></p> </li> </ol>"},{"location":"lectures/lec002/#formal-parameters-arguments","title":"Formal Parameters &amp; Arguments","text":"<ul> <li>When a function is invoked, the formal parameters are initialized from the arguments, and the statements in the function body are executed.</li> <li>The initialization operation depends on the type of the formal parameters. There are two basic types: call-by-value parameters and call-by-reference parameters.</li> <li>Consider the following program:     Sum of Two Numbers<pre><code>#include &lt;iostream&gt;\n\nvoid input (char, int &amp;);\n\nint main()\n{\n    int a, b;\n\n    input('a', a);\n    input('b', b);\n\n    std::cout &lt;&lt; \"The sum = \" &lt;&lt; a+b &lt;&lt; std::endl;\n    return 0;\n}\n\nvoid input (char c, int &amp;value)\n{\n    std::cout &lt;&lt; \"Enter the value of \" &lt;&lt; c &lt;&lt; \": \";\n    std::cin &gt;&gt; value;\n}\n</code></pre></li> <li>When the program executes line 9, the control transfers to line 16 and the paramters are initialized as follows:     <pre><code>char c = 'a';\nint &amp;value = a;\n</code></pre>     Therefore, variable <code>c</code> will be created and initialized with the value of <code>'a'</code>, and the variables <code>value</code> and <code>a</code> will refer to the same object. The variable <code>a</code> is invisible (out of its scope).  However, its object is accessible by the variable <code>value</code>. </li> <li>After initialization, the control transfers to line 18 and the following message will be displayed:     <pre><code>Enter the value of a: \n</code></pre>     Then, the control transfers to line 19. At this moment, the program is waiting for the user to enter a value. Once the user enters a value, the value will be stored into the object named by <code>value</code>. Remember, that object has two references: the variable <code>value</code> and the variable <code>a</code>.</li> <li>After executing line 19, the object referenced by <code>c</code> is destroyed, the variable <code>value</code> is removed and the control transfers back to line 9.</li> <li>Then the control transfers to line 10 and the function <code>input</code> will be invoked again. The control transfers to line 16 again. This time, the paramters are initialized as follows:     <pre><code>char c = 'b';\nint &amp;value = b;\n</code></pre></li> <li>Then, lines 18 and 19 are executed accordingly.</li> <li> <p>Here is a sample output of the program:</p> <p>Program ouput with input shown in bold</p> <p>Enter the value of a: 13  Enter the value of b: 34  The sum = 47</p> </li> </ul>"},{"location":"lectures/lec002/#exercise_1","title":"Exercise","text":"<p>Exercise</p> <p></p> <p>Write a program that lets the user play the game of Rock, Paper, Scissors against the computer. The program should work as follows:</p> <ol> <li>When the program begins, a random number in the range of 1 through 3 is generated. If the number is 1, then the computer has chosen rock. If the number is 2, then the computer has chosen paper. If the number is 3, then the computer has chosen scissors. (Don\u2019t display the computer\u2019s choice yet.)</li> <li>The user enters his or her choice of \u201crock\u201d, \u201cpaper\u201d, or \u201cscissors\u201d at the keyboard. (You can use a menu if you prefer.)</li> <li>The computer\u2019s choice is displayed.</li> <li>A winner is selected according to the following rules:<ul> <li>If one player chooses rock and the other player chooses scissors, then rock wins. (The rock smashes the scissors.)</li> <li>If one player chooses scissors and the other player chooses paper, then scissors wins. (Scissors cuts paper.)</li> <li>If one player chooses paper and the other player chooses rock, then paper wins. (Paper wraps rock.)</li> <li>If both players make the same choice, the game must be played again to determine the winner.</li> </ul> </li> </ol> <p>Be sure to divide the program into functions that perform each major task.</p> <p>If you are not familiar with this game, watch this Youtube video </p>"},{"location":"lectures/lec011/","title":"Lecture 1: Structures","text":""},{"location":"lectures/lec011/#user-defined-types","title":"User-Defined Types","text":"<ul> <li>Recall that a type defines a set of possible values and a set of operations defined on them.</li> </ul> <p>Example</p> <p>To illustrate the above definition, consider the following data types :</p> Data type The set of possible values The set of operations <code>int</code> From -2,147,483,648 up to 2,147,483,647 <code>*</code>, <code>/</code>, <code>%</code>, <code>&amp;</code>, <code>+</code>, <code>&gt;</code>, <code>==</code>, etc. <code>double</code> From 1.7E-308 to 1.7E+308 <code>*</code>, <code>/</code>, <code>&amp;</code>, <code>+</code>, <code>&gt;</code>, <code>==</code>, etc. <p>Notice that the operation <code>%</code> is not defined in <code>double</code>. If you try to compile the expression <code>4.0 % 3.0</code>, the compiler will emit the following error message: <code>error: invalid operands of types 'double' and 'double' to 'operator%'</code></p> <ul> <li>A type is called built-in if the compiler knows how to represent objects of the type and which operations can be done on it without being told by a programmer in source code.</li> <li>Types that are not built-in are called user-defined types (UDTs).</li> <li>In C++, there are two ways to build UDTs:<ol> <li>by using structures (or classes)</li> <li>by using enumeration</li> </ol> </li> </ul> <p> Why do we need to build a new type?</p> <p>Built-in types are too primitives. It is desirable that types can directly represent our ideas in code. When we write code, the ideal is to represent our ideas directly in our code so that we, our colleagues, and the compiler can understand what we wrote. For example, let us assume that we have a type called <code>Date</code> to represent a date in the form dd/mm/yyyy. Which program do you consider more clearer to understand?</p> <p>First code:</p> <pre><code>int d1 = 10 , m1 = 3, y1 = 2020; // first date 10/3/2020\nint d2 = 30 , m2 = 4, y2 = 2022; // second date 30/4/2022\n\nint diff = subtract(d2 , m2 , y2 , d1 , m1 , y1);\nif ( diff &gt;= 0)\n    cout &lt;&lt; \" The number of days = \" &lt;&lt; diff &lt;&lt; endl ;\nelse\n    cout &lt;&lt; \" The number of days = \" &lt;&lt; subtract(d1 , m1 , y1 , d2 , m2 , y2) &lt;&lt; endl ;\n</code></pre> <p>Second code:</p> <pre><code>Date d1 {10 , 3, 2020}; // first date 10/3/2020\nDate d2 {30 , 4, 2022}; // second date 30/4/2022\n\nif (d2 &gt;= d1)\n    cout &lt;&lt; \" The number of days = \" &lt;&lt; d2 - d1 &lt;&lt; endl ;\nelse\n    cout &lt;&lt; \" The number of days = \" &lt;&lt; d1 - d2 &lt;&lt; endl ;\n</code></pre> <p>The second code allows us to directly represent our ideas more than the first code.</p> <ul> <li>We say a user-defined type is a \"good\" type, if it helps us to express our ideas clearly. The help comes in two forms:<ul> <li> Representation: A type knows how to represent the data needed in an object.</li> <li> Operations: A type knows what operations can be applied to objects.</li> </ul> </li> </ul> <p></p> <p>The main objective of this course is to learn how to build a good data type</p>"},{"location":"lectures/lec011/#structures","title":"Structures","text":"<ul> <li>Most often, we want to create a new type by bundling (aggregating) serveral related information about one thing under one type. For example, we need a type <code>Date</code> that bundles three integers: day, month and year.</li> <li>The simplest way is to use structure type.</li> <li>A structure is a user-defined type. It is composed of built\u2013in types and/or other user-defined types. The parts used to define the structure are called members. A structure has zero or more members.</li> <li>Let us define a type <code>Time</code> that bundles two integers: <code>hour</code> and <code>minutes</code>. </li> </ul> Example of a UDT<pre><code>// a structure with two members to represent time\nstruct Time\n{\n    int hour;\n    int minutes;\n};\n</code></pre> <ul> <li>The structure definition above is known as type definition. The keyword <code>struct</code> announces that this is a structure\u2013type definition. The identifier <code>Time</code> is the name of the structure type, which is known as the structure tag.</li> <li>The structure tag can be any legal identifier that is not a keyword.</li> <li>The identifiers declared inside the braces, <code>{}</code>, are called members.</li> <li>The structure-type definition must end with a semicolon.</li> </ul>"},{"location":"lectures/lec011/#the-dot-operator","title":"The Dot Operator","text":"<ul> <li>We can define variables of structure types just like we do for built-in types.     Example<pre><code>Time start;\n</code></pre></li> <li> <p>The semantics of the above example is as follows:</p> <ul> <li>This is a definition statement. It creates two objects in the following order:<ol> <li>The first object is of type <code>int</code>, and it will be named <code>hour</code></li> <li>The second object is of type <code>int</code>, and it will be named <code>minutes</code></li> </ol> </li> <li>The aggregated structure will be named <code>start</code></li> </ul> </li> <li> <p>We can visualize <code>start</code> as a package that consists of two items: <code>hour</code> and <code>minutes</code></p> </li> <li> <p>Let us consider another example:     Example<pre><code>Time start, end;\n</code></pre></p> </li> <li>In this definition statement, the compiler will create two packages (or structures) and each package has its own items as depicted in the diagram.</li> </ul> <p></p> <ul> <li>The member objects are referenced by giving the name of the structure variable followed by a dot and then the member name. For example, <code>start.hour</code>, which represents the object named by <code>hour</code> inside the package <code>start</code>.</li> </ul> <p>The . Operator</p> <p>The dot operator is used to specify a member variable of a structure variable.</p> <p>SYNTAX</p> <p><code>&lt;Structure_Variable_Name&gt;</code>.<code>&lt;Member_Variable_Name&gt;</code></p> <ul> <li>Let us consider our first program. We will call this program Time Program:</li> </ul> <p>Time Program version (1.0)</p> <p>The elapsed time of an event is the amount of time that has passed between the commencement and the completion of an event. If an event starts at 12:00 and ends at 14:00, the elapsed time is the time that has passed between 12:00 and 14:00, which is 2 hours. We assume here the times are in the 24-hour time.</p> <p>In this example, we write a program that reads the starting time and the ending time of an event in 24-hour format within the same day. Then, it computes the elapsed time and displays the result on the screen monitor.</p> <p>INPUT: starting and ending times</p> <p>PROCESS: Compute the elapsed time</p> <p>OUTPUT: elapsed time</p> <p>Therefore, we need to declare the following variables: <pre><code>Time start;     // starting time\nTime end;       // ending time\nTime elap;      // elapsed time\n</code></pre> The elapsed time is computed by subtracting the starting time from the ending time. To obtain the result correctly, we need to determine whether the number of minutes is larger in the starting time or the ending time.</p> <ol> <li> <p>If the ending time has a larger number of minutes: Subtract normally. For example:</p> \\[ \\begin{array}{rrr}     &amp; 13 &amp;: 45 \\\\     -&amp; 9 &amp;: 10 \\\\ \\hline     &amp; 4 &amp;: 35 \\end{array} \\] </li> <li> <p>If the starting time has a larger number of minutes: Add 60 to the number of minutes in the ending time, and subtract 1 hour from the hour portion of the ending time. Then, subtract normally. For example:</p> \\[ \\begin{array}{rrr}     &amp; 13 &amp;: 10 \\\\     -&amp; 9 &amp;: 45 \\\\ \\hline     &amp;  &amp; \\end{array} \\;\\; \\Rightarrow \\;\\;  \\begin{array}{rrr}     &amp; 12 &amp;: 70 \\\\     -&amp; 9 &amp;: 45 \\\\ \\hline     &amp; 3 &amp;: 25 \\end{array} \\] </li> </ol> <p>We translate the above logic into C++ as follows: <pre><code>if (end.minutes &gt;= start.minutes) {\n    elap.minutes = end.minutes - start.minutes;\n    elap.hour = end.hour - start.hour;\n}\nelse {\n    elap.minutes = (end.minutes + 60) - start.minutes;\n    elap.hour = (end.hour - 1) - start.hour;\n} \n</code></pre></p> <p>The final task is to print out the elapsed time in HH:MM format:</p> <pre><code>cout &lt;&lt; setfill ('0') &lt;&lt; setw (2) &lt;&lt; elap.hour &lt;&lt; ':' &lt;&lt; setw (2) &lt;&lt; elap.minute &lt;&lt; endl ;\n</code></pre> <p>Now, we can write the whole program: <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing namespace std;\n\nstruct Time // UDT\n{\n    int hour;\n    int minutes;\n};\n\nint main() \n{\n    char dummy;     // to read ':'\n    Time start;     // the starting time\n    Time end;       // the ending time\n\n    cout &lt;&lt; \"Enter the starting time (HH:MM): \";\n    cin &gt;&gt; start.hour &gt;&gt; dummy &gt;&gt; start.minutes;\n    cout &lt;&lt; \"Enter the ending time (HH:MM): \";\n    cin &gt;&gt; end.hour &gt;&gt; dummy &gt;&gt; end.minutes;\n\n    Time elap;      // The elapsed time\n    if (end.minutes &gt;= start.minutes) {\n        elap.minutes = end.minutes - start.minutes;\n        elap.hour = end.hour - start.hour;\n    }\n    else {\n        elap.minutes = (end.minutes + 60) - start.minutes;\n        elap.hour = (end.hour - 1) - start.hour;\n    } \n\n    cout &lt;&lt; \"The elapsed time is \";\n    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; elap.hour &lt;&lt; ':' &lt;&lt; setw(2) &lt;&lt; elap.minutes &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre></p>"},{"location":"lectures/lec011/#the-assignment-statement","title":"The Assignment Statement","text":"<ul> <li> <p>The compiler knows how to assign a structure variable to another structure variable of the same type. </p> </li> <li> <p>The compiler simply moves (as a copy) the rvalue of each member variable in the RHS and stores it to the lvalue of its corresponding member variable in LHS.  </p> </li> <li> <p>Now, consider the following assignment statement: <pre><code>elap = end;\n</code></pre> Here the compiler assigns the value of <code>end.hour</code> to <code>elap.hour</code> and assgins the value of <code>end.minutes</code> to <code>elap.minutes</code>, as if the compiler performs the following statements: <pre><code>elap.hour = end.hour;\nelap.minutes = end.minutes;\n</code></pre></p> </li> </ul> <p>Default Structure Operations</p> <p>By default, the compiler ONLY knows how to evaluate the assignment operator <code>=</code> for structure types. You cannot perform other operations directly on structure variables. The following statement will cause an error: <pre><code>if (start == end)  // Error\n</code></pre></p> <p>For now, to compare two structures, you must compare the individual members, as shown in the following code: <pre><code>if (start.hour == end.hour &amp;&amp; start.minutes == end.minutes) \n</code></pre></p>"},{"location":"lectures/lec011/#structure-initialization","title":"Structure Initialization","text":"<ul> <li> <p>A structure variable can be initialized using list initialization, direct initialization or copy initialization. Let us consider the following examples:</p> <pre><code>Time t1 = {10, 25};                 // list-initializer -- C ++98\nTime t2 {10, 25};                   // list-initializer -- since C ++11\nTime t3 = {.hour=10, .minute=25};   // designated list-initializer -- since C ++20\nTime t4 {.hour=10, .minute=25};     // designated list-initializer -- since C ++20\nTime t5 = t1;                       // copy-initializer\nTime t6 (t1);                       // direct-initializer\n</code></pre> </li> <li> <p>The following initialization operations are valid:     <pre><code>Time t0 = {};           // OK: .hour = 0, .minute = 0\nTime t1 = {10};         // OK: .hour = 10, .minute = 0\nTime t2 {.minute=25};   // OK: .hour = 0, .minute = 25\nTime t3;                // default initialization\n</code></pre></p> </li> <li> <p>The following initialization operations are NOT valid:     <pre><code>Time t1 = {10, 25, 7};          // Error: no corresponding member for \u20197\u2019\nTime t2 {.minute=25, .hour=10}; // Error: list must be in order\nTime t3 { , 25};                // Error: ill-formed initializer list\n</code></pre></p> </li> <li> <p>A member variable can have a default initializer as shown below:     <pre><code>struct Time\n{\n    int hour = 23;      // default member initializer\n    int minute = 59;    // default member initializer\n};\n\nint main ()\n{\n    Time t1;                // .hour = 23 , .minute = 59\n    Time t2 {};             // .hour = 23 , .minute = 59\n    Time t3 = {.minute=0};  // .hour = 23 , .minute = 0\n    Time t4 = {10};         // .hour = 10 , .minute = 59\n    .\n    .\n}\n</code></pre></p> </li> </ul> <p>Time Program version (1.1)</p> <p>In this example, we modify the code that computes the elapsed time. Our new logic is:</p> <ol> <li>Set the elapsed time equals to the ending time.</li> <li>Add 60 to the number of minutes in the elapsed time and subtract 1 hour from the hour portion of the elapsed time ONLY when the number of minutes in the starting time is larger than the number of minutes in the elapsed time.</li> <li>Subtract the starting time from the elapsed time.</li> </ol> <p>We translate the above logic as follows: <pre><code>Time elap = end;    // this is a copy initialization\n\nif (start.minutes &gt; elap.minutes) {\n    elap.minutes += 60;\n    elap.hour --;\n}\nelap.minutes -= start.minutes;\nelap.hour -= start.hour;\n</code></pre></p> <p>Here is the complete Time Program version (1.1)</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nusing namespace std;\n\nstruct Time // UDT\n{\n    int hour;\n    int minutes;\n};\n\nint main() \n{\n    char dummy;     // to read ':'\n    Time start;     // the starting time\n    Time end;       // the ending time\n\n    cout &lt;&lt; \"Enter the starting time (HH:MM): \";\n    cin &gt;&gt; start.hour &gt;&gt; dummy &gt;&gt; start.minutes;\n    cout &lt;&lt; \"Enter the ending time (HH:MM): \";\n    cin &gt;&gt; end.hour &gt;&gt; dummy &gt;&gt; end.minutes;\n\n    Time elap = end;    // The elapsed time\n    if (start.minutes &gt; elap.minutes) {\n        elap.minutes += 60;\n        elap.hour--;\n    }\n    elap.minutes -= start.minutes;\n    elap.hour -= start.hour; \n\n    cout &lt;&lt; \"The elapsed time is \";\n    cout &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; elap.hour &lt;&lt; ':' &lt;&lt; setw(2) &lt;&lt; elap.minutes &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> <p>Self-Check</p> QuestionsAnswers <ol> <li> <p>Write a structure definition to hold the following data about a banking account: </p> <ul> <li>Account Number (string object)</li> <li>Account Balance (double)</li> <li>Account Type (int)</li> <li>Average Monthly Balance (double)</li> </ul> </li> <li> <p>Given the following struct definition:     <pre><code>struct A\n{\n    int b;\n    int c;\n};\n</code></pre>     declare <code>x</code> to have this structure type. Initialize the members of <code>x</code>, member <code>b</code> and member <code>c</code>, to the values 1 and 2, respectively.</p> </li> </ol> <ol> <li> <pre><code>struct BankAccount \n{\n    string accountNumber;\n    double accountBalance;\n    int accountType;\n    double avgMonthlyBalance;\n};\n</code></pre> </li> <li> <p><code>A x = {1, 2};</code></p> </li> </ol>"},{"location":"lectures/lec011/#structures-as-function-arguments","title":"Structures as Function Arguments","text":"<ul> <li>Like other variables, structure variables can be passed as arguments to functions, using both call-by-value or call-by-reference.</li> </ul> <p>Time Program version (2.0)</p> <p>In this example, we are going to define two functions:</p> <ol> <li><code>subtractTime()</code>, and</li> <li><code>printTime()</code>.</li> </ol> <p>If \\(t_1\\) and \\(t_2\\) are two <code>Time</code> variables in HH:MM format, then the function <code>subtractTime(t2, t1)</code> will subtract \\(t_1\\) from \\(t_2\\) to get a new time \\(r\\) (where \\(r = t_2 - t_1\\)). As such, the function <code>subtractTime()</code> takes two arguments of type <code>Time</code> and returns a new object of type <code>Time</code>. The function prototype shall be: <pre><code>Time subtractTime (Time, Time);\n</code></pre></p> <p>And, here is the function defintition based on Time Program version (1.1): <pre><code>Time subtractTime (Time t2, Time t1)\n{\n    Time elap = t2;\n\n    if (t1.minutes &gt; elap.minutes) {\n        elap.minutes += 60;\n        elap.hour--;\n    }\n    elap.hour -= t1.hour;\n    elap.minutes -= t1.minutes;\n\n    return elap;\n}\n</code></pre></p> <p>For the second function <code>printTime()</code>, it takes one argument of type <code>Time</code> and prints it out to screen monitor in HH:MM format. So, the prototype of the function becomes as follows: <pre><code>void printTime (Time);\n</code></pre></p> <p>As for the function definition, we may write it as follows: <pre><code>void printTime (Time t)\n{\n    std::cout \n        &lt;&lt; std::setfill('0') \n        &lt;&lt; std::setw(2) &lt;&lt; t.hour \n        &lt;&lt; ':' \n        &lt;&lt; std::setw(2) &lt;&lt; t.minutes;\n}\n</code></pre></p> <p>Now, here is the Time Program version (2.0): <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nstruct Time \n{\n    int hour;\n    int minutes;\n};\n\nTime subtractTime (Time, Time);\nvoid printTime (Time);\n\nint main() \n{\n    char dummy;     // to read ':'\n    Time start;     // the starting time\n    Time end;       // the ending time\n\n    std::cout &lt;&lt; \"Enter the starting time (HH:MM): \";\n    std::cin &gt;&gt; start.hour &gt;&gt; dummy &gt;&gt; start.minutes;\n    std::cout &lt;&lt; \"Enter the ending time (HH:MM): \";\n    std::cin &gt;&gt; end.hour &gt;&gt; dummy &gt;&gt; end.minutes;\n\n    Time elap;\n\n    elap = subtractTime(end, start);\n\n    std::cout &lt;&lt; \"The elapsed time is \";\n    printTime(elap);\n\n    return 0;\n}\n\nTime subtractTime (Time t2, Time t1)\n{\n    Time elap = t2;\n\n    if (t1.minutes &gt; elap.minutes) {\n        elap.minutes += 60;\n        elap.hour--;\n    }\n    elap.hour -= t1.hour;\n    elap.minutes -= t1.minutes;\n\n    return elap;\n}\n\nvoid printTime (Time t)\n{\n    std::cout    \n        &lt;&lt; std::setfill('0') \n        &lt;&lt; std::setw(2) &lt;&lt; t.hour \n        &lt;&lt; ':' \n        &lt;&lt; std::setw(2) &lt;&lt; t.minutes;\n}\n</code></pre></p> <ul> <li>Let us concentrate on the function calls, the highlighted lines, inside the <code>main</code> function. </li> <li>At Line 26, the funtion <code>subtractTime()</code> is called as part of evaluating the assignment statement. Let us track exactly the execution of this statement.<ul> <li>When the function is called, the control transfers from Line 26 to Line 34. </li> <li>The parameters are copy-initialized as follows:     <pre><code>Time t2 = end;      // copy initialization\nTime t1 = start;    // copy initialization\n</code></pre></li> <li>At line 36, the variable <code>elap</code> is constructed and copy-initialized from <code>t2</code>. </li> <li>Next, the <code>if</code> statement is executed (Lines 38-41) followed by two assignments (Lines 42 and 43).</li> <li>When the function returns, the compiler creates a temporary object of type <code>Time</code> to hold the return value. So, the compiler will execute the following statement behind the scenses:     <pre><code>Time tempObj = elap;\n</code></pre>     As such the <code>tempObj</code> is copy-initialized from <code>elap</code>.</li> <li>Next, the control transfers back to Line 26 and the compiler executes the assignment statement as follows:     <pre><code>elap = tempObj\n</code></pre>     which moves the data from <code>tempObj</code> to <code>elap</code>, and the execution of this line is complete.</li> </ul> </li> </ul> <p>Question</p> <p>What will happen when Line 28 of Time Program version (2.0) is executed?</p> <p>READ-ONLY: Copy Elision (C++ feature)</p> <ul> <li>Let us, informally, denote <code>subtractTime()::elap</code> to indicate the variable <code>elap</code> defined inside the function <code>subtractTime()</code>.</li> <li>Now, you may have noticed that <code>subtractTime()::elap</code> variable has been copied to <code>tempObj</code>, and the variable <code>tempObj</code> has been copied to <code>main()::elap</code>.</li> <li>Can we move the data from <code>subtractTime()::elap</code> to <code>main()::elap</code> directly?</li> <li>The answer is Yes; this is known as copy elision.</li> <li>For more information, read this page</li> <li>We can utilize this optimization by rewriting the <code>main()</code> function as follows: <pre><code>int main() \n{\n    char dummy;     // to read ':'\n    Time start;     // the starting time\n    Time end;       // the ending time\n\n    std::cout &lt;&lt; \"Enter the starting time (HH:MM): \";\n    std::cin &gt;&gt; start.hour &gt;&gt; dummy &gt;&gt; start.minutes;\n    std::cout &lt;&lt; \"Enter the ending time (HH:MM): \";\n    std::cin &gt;&gt; end.hour &gt;&gt; dummy &gt;&gt; end.minutes;\n\n    std::cout &lt;&lt; \"The elapsed time is \";\n    printTime(subtractTime(end, start));\n\n    return 0;\n}\n</code></pre></li> <li>This will allow to copy/move data from <code>subtractTime()::elap</code> to <code>printTime()::t</code> directly.</li> </ul> <ul> <li>Let us redefine the function <code>subtractTime()</code> by utilizing the structure initialization. In the following code, the return value (<code>tempObj</code>) is constructed using list-initlializer.     <pre><code>Time subtractTime (Time t2, Time t1)\n{\n    int h = t2.hour;\n    int m = t2.minutes;\n\n    if (t1.minutes &gt; m) {\n        m = m + 60;\n        h = h - 1;\n    }\n    return Time{h - t1.hour, m - t1.minutes};\n}\n</code></pre></li> </ul>"},{"location":"lectures/lec011/#constant-reference-parameters","title":"Constant Reference Parameters","text":"<ul> <li>How many times the copy initialization has been applied in the Time Program version (2.0)?</li> <li>In real applications, structure-types can be quite large. </li> <li>If a structure-type is large, then each copy initialization will take significant amount of CPU time and, hence, reduce the program's performance.</li> <li>To tacke this problem (i.e., avoiding copy initialization), we can pass these large structures by reference.     Example<pre><code>.\n.\nint main()\n{\n    .\n    .\n    Time elap = subtractTime(end, start);\n    .\n    .\n}\n\nTime subtractTime (Time &amp;t2, Time &amp;t1)\n{\n    .\n    .\n}\n</code></pre></li> <li>Now, when the function <code>subtractTime()</code> is invoked, the parameters <code>t2</code> and <code>t1</code> will be initialized as follows:     <pre><code>Time &amp;t2 = end;\nTime &amp;t1 = start;\n</code></pre>     This implies that <code>t2</code> is just another reference to the same object that referenced by <code>end</code>. Similarly, <code>t1</code> and <code>start</code> refer to the same object. As a result, no copy initialization is performed.</li> <li>However, we need to preserve the semantics that <code>end</code> and <code>start</code> are passed by values (not as reference). The trick is to add the type qualifier <code>const</code> as follows:     <pre><code>Time subtractTime (const Time &amp;t2, const Time &amp;t1)\n</code></pre></li> <li>Here is an enhanced version of the Time Program     Time Program version (2.1)<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nstruct Time \n{\n    int hour;\n    int minutes;\n};\n\nTime subtractTime (const Time&amp;, const Time&amp;);\nvoid printTime (const Time&amp;);\n\nint main() \n{\n    char dummy;     // to read ':'\n    Time start;     // the starting time\n    Time end;       // the ending time\n\n    std::cout &lt;&lt; \"Enter the starting time (HH:MM): \";\n    std::cin &gt;&gt; start.hour &gt;&gt; dummy &gt;&gt; start.minutes;\n    std::cout &lt;&lt; \"Enter the ending time (HH:MM): \";\n    std::cin &gt;&gt; end.hour &gt;&gt; dummy &gt;&gt; end.minutes;\n\n    std::cout &lt;&lt; \"The elapsed time is \";\n    printTime(subtractTime(end, start));\n\n    return 0;\n}\n\nTime subtractTime (const Time &amp;t2, const Time &amp;t1)\n{\n    Time elap = t2;\n\n    if (t1.minutes &gt; elap.minutes) {\n        elap.minutes += 60;\n        elap.hour--;\n    }\n    elap.hour -= t1.hour;\n    elap.minutes -= t1.minutes;\n\n    return elap;\n}\n\nvoid printTime (const Time &amp;t)\n{\n    std::cout    \n        &lt;&lt; std::setfill('0') \n        &lt;&lt; std::setw(2) &lt;&lt; t.hour \n        &lt;&lt; ':' \n        &lt;&lt; std::setw(2) &lt;&lt; t.minutes;\n}\n</code></pre></li> </ul>"},{"location":"lectures/lec011/#arrays-of-structures","title":"Arrays of Structures","text":"<ul> <li>An array of structure is defined like any other array.</li> <li>Let us assume we have 10 events and we need to store the starting time of these events. We can define an array of 10 elements and each element is a <code>Time</code> structure.     Example<pre><code>Time start[10];\n</code></pre></li> <li>Here, each element is a variable of type <code>Time</code>. For example, the starting time of the first event is stored in <code>start[0]</code> variable.</li> <li>The following expression refers to the hour portion of the first event's starting time:     <pre><code>start[0].hour\n</code></pre></li> <li>The following loop steps through the array, displaying the data stored in each element:     <pre><code>std::cout &lt;&lt; \"Today's events are scheduled at:\" &lt;&lt; std::endl;\nfor (int i=0; i&lt;10; i++) {\n    std::cout &lt;&lt; \"Event #\" &lt;&lt; (i+1) &lt;&lt; \" starts at \";\n    printTime(start[i]);\n    std::cout &lt;&lt; std::endl;\n}\n</code></pre></li> </ul>"},{"location":"lectures/lec011/#initializing-a-structure-array","title":"Initializing a Structure Array","text":"<ul> <li>Aggregated data types (arrays &amp; structures) are initialized using list-initializer. For example:     <pre><code>Time start[] = {\n    {10, 00},       // first event\n    {11, 15},       // second event\n    {12, 30}        // third event\n};\n</code></pre></li> </ul> <p>List of Events</p> <p>In this example, Let us store the starting and ending times for a number of events in two separate arrays:</p> <ol> <li><code>start</code>: Each element in this array holds the starting time of an event.</li> <li><code>end</code>: Each element in this array holds the ending time of an event.</li> </ol> <p>Therefore, we translate the above logic as follows: <pre><code>constexpr int NUM_OF_EVENTS = 10;   // The number of events to be stored\nTime start[NUM_OF_EVENTS];\nTime end[NUM_OF_EVENTS];\n</code></pre></p> <p>Thus, the starting time and the ending time for event \\(i\\) are stored in <code>start[i]</code> and <code>end[i]</code>, respectively.</p> <p>Here is the complete program where the data related to the events is hardcoded in the program.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nstruct Time \n{\n    int hour;\n    int minutes;\n};\n\nTime subtractTime (Time, Time);\nvoid printTime (Time);\n\nint main() \n{\n    constexpr int NUM_OF_EVENTS = 3;\n    Time start[NUM_OF_EVENTS] = {   // the starting time\n        {9, 0},\n        {10, 30},\n        {12, 00}\n    };     \n    Time end[NUM_OF_EVENTS] = {     // the ending time\n        {10, 15}, \n        {11, 45},\n        {12, 45}\n    }; \n\n    std::cout &lt;&lt; \"Event # \\tStart Time \\tEnd Time \\tDuration\\n\";  // table header\n\n    for (int i=0; i&lt;NUM_OF_EVENTS; i++) {\n        std::cout &lt;&lt; std::setw(7) &lt;&lt; (i+1) &lt;&lt; \"\\t\\t\";\n        printTime(start[i]);    \n        std::cout &lt;&lt; \"\\t\\t\";\n        printTime(end[i]);      \n        std::cout &lt;&lt; \"\\t\\t\";\n        printTime(subtractTime(end[i], start[i]));\n        std::cout &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n\nTime subtractTime (Time t1, Time t2)\n{\n    int h = t1.hour;\n    int m = t1.minutes;\n\n    if (t2.minutes &gt; m) {\n        m = m + 60;\n        h = h - 1;\n    }\n    return Time{h-t2.hour, m-t2.minutes};\n}\n\nvoid printTime (Time t)\n{\n    std::ostream screen (std::cout.rdbuf());\n    screen    \n        &lt;&lt; std::setfill('0') \n        &lt;&lt; std::setw(2) &lt;&lt; t.hour \n        &lt;&lt; ':' \n        &lt;&lt; std::setw(2) &lt;&lt; t.minutes;\n}\n</code></pre> <p>The output is shown below:</p> <p>Three events</p> <pre><code>Event #         Start Time      End Time        Duration\n      1         09:00           10:15           01:15\n      2         10:30           11:45           01:15\n      3         12:00           12:45           00:45\n</code></pre>"},{"location":"lectures/lec011/#data-structures-software-engineering","title":"Data Structures (Software Engineering)","text":"<ul> <li>Representing a list of events using two separate arrays might complicate your program, especially if you need to add more data related to the events.</li> <li>We can build structures within a structure, also known as nested structures.</li> <li>Here is a better way to represent an event:     Data representation for an event<pre><code>struct Time {\n    int hour;\n    int minutes;\n};\nstruct Event {\n    Time start;\n    Time end;\n};\n</code></pre></li> <li>Now, we can define a variable of type <code>Event</code> as follows:     <pre><code>Event lunch;\n</code></pre></li> <li> <p>The <code>lunch</code> variable can be visualized as follows: </p> <p>The <code>lunch</code> variable has two members: <code>start</code> and <code>end</code>, and <code>lunch.start</code> has two members: <code>hour</code> and <code>minutes</code>.</p> </li> <li> <p>To set the starting time of the lunch event, we write:     <pre><code>lunch.start.hour = 12;\nlunch.start.minutes = 20;\n</code></pre></p> </li> <li>The represetation allows us to add more data easily. For example:     <pre><code>struct Event {\n    string  title;  // event name\n    Time    start;  // starting time\n    Time    end;    // ending time\n    string  venue;  // event location\n};\n</code></pre></li> <li>To set the <code>lunch</code> variable using the last definition:     <pre><code>Event lunch = {\n    \"Lunch Time\",\n    {12, 20},\n    {01, 00},\n    \"2nd Floor\"\n};\n</code></pre></li> </ul> <p>List of Events v2.0</p> <p>This example defines <code>Event</code> data type, which consists of two members: <code>start</code> and <code>end</code>.</p> <p>Then, we define a variable <code>eve</code> where <code>eve</code> is an array of Events: <pre><code>Event eve [NUM_OF_EVENTS];\n</code></pre></p> <p>The first event has index <code>0</code>. We can access <code>start</code> object as follows: <pre><code>eve[0].start\n</code></pre></p> <p>If we need to set the starting time of the first event to time 09:30, then: <pre><code>eve[0].start.hour = 9;\neve[0].start.minutes = 30;\n</code></pre></p> <p>Here is a better version of \"List of events\" program. <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nstruct Time \n{\n    int hour;\n    int minutes;\n};\nstruct Event\n{\n    Time start;\n    Time end;\n};\n\nTime subtractTime (const Time&amp;, const Time&amp;);\nvoid printTime (const Time&amp;);\n\nint main() \n{\n    constexpr int NUM_OF_EVENTS = 3;\n    Event eve[NUM_OF_EVENTS] = {\n        { {9, 0},   {10, 15}  },\n        { {10, 30}, {11, 45}  },\n        { {12, 00}, {12, 45}  }\n    };     \n\n    std::cout &lt;&lt; \"Event # \\tStart Time \\tEnd Time \\tDuration\\n\";  // table header\n\n    for (int i=0; i&lt;NUM_OF_EVENTS; i++) {\n        std::cout &lt;&lt; std::setw(7) &lt;&lt; (i+1) &lt;&lt; \"\\t\\t\";\n        printTime(eve[i].start);    \n        std::cout &lt;&lt; \"\\t\\t\";\n        printTime(eve[i].end);      \n        std::cout &lt;&lt; \"\\t\\t\";\n        printTime(subtractTime(eve[i].end, eve[i].start));\n        std::cout &lt;&lt; '\\n';\n    }\n\n    return 0;\n}\n\nTime subtractTime (const Time&amp; t1, const Time&amp; t2)\n{\n    int h = t1.hour;\n    int m = t1.minutes;\n\n    if (t2.minutes &gt; m) {\n        m = m + 60;\n        h = h - 1;\n    }\n    return Time{h-t2.hour, m-t2.minutes};\n}\n\nvoid printTime (const Time&amp; t)\n{\n    std::ostream screen (std::cout.rdbuf());\n    screen    \n        &lt;&lt; std::setfill('0') \n        &lt;&lt; std::setw(2) &lt;&lt; t.hour \n        &lt;&lt; ':' \n        &lt;&lt; std::setw(2) &lt;&lt; t.minutes;\n}\n</code></pre></p>"},{"location":"lectures/lec011/#defining-operations-for-udts","title":"Defining Operations for UDTs","text":"<ul> <li>As we mentioned, built-in data types has a set of operations defined on them.</li> <li>Even though C++ compiler defines many built-in operations, it cannot cover all operations. For example, C++ does not define the exponent/power operations (\\(x^y\\)). Those missing operations are mostly provided by the C++ Standard Library. For example, the exponent operation is defined in <code>cmath</code> header file as <code>pow()</code>. For example, \\(3^5\\) can be expressed as <code>pow(3, 5)</code>.</li> <li>C++ Standard Library also defined functions (operations) that are easier to read and understand. For example, although we can express \\(\\sqrt{x}\\) using <code>pow(x, 0.5)</code>, the library provided an operation that is more easier to read and understand, which is <code>sqrt(x)</code>. Put this note in your mind.</li> <li>Similarly, for UDTs, we can define operations through functions. </li> <li>For example, for the data type <code>Time</code>, we already defined two operations on them:<ul> <li><code>subtractTime()</code>, and</li> <li><code>printTime()</code></li> </ul> </li> <li>We can define more operations as suggested in the following example:</li> </ul> <p>More operations on <code>Time</code> data type: Time Program version (3.0)</p> <p>In this example, we are going to define two additional operations on <code>Time</code>:</p> <ul> <li><code>compareTime()</code></li> <li><code>addMinutes()</code></li> </ul> <p>Let us devise a comparison operation between two times as follows. Let \\(f(t_1, t_2)\\) be a function such that:</p> \\[ f(t_1, t_2)  = \\begin{cases}     1 &amp; \\text{if } t_1 &gt; t_2 \\\\     0 &amp; \\text{if } t_1 = t_2 \\\\     -1 &amp; \\text{if } t_1 &lt; t_2  \\end{cases} \\] <p>When do we tell \"logically\" that \\(t_1 &gt; t_2\\) or \\(t_1 &lt; t_2\\) or \\(t_1 = t_2\\)?</p> <p>First, we examine the hour portion, and here we have three cases:</p> <ol> <li>\\(t_1.hour &gt; t_2.hour\\): This implies \\(t_1 &gt; t_2\\)</li> <li>\\(t_1.hour &lt; t_2.hour\\): This implies \\(t_1 &lt; t_2\\)</li> <li>\\(t_1.hour = t_2.hour\\): At this case, we must examine the minutes part. Here, we have three cases:<ol> <li>\\(t_1.minutes &gt; t_2.minutes\\): This implies \\(t_1 &gt; t_2\\).</li> <li>\\(t_1.minutes &lt; t_2.minutes\\): This implies \\(t_1 &lt; t_2\\).</li> <li>\\(t_1.minutes = t_2.minutes\\): This implies \\(t_1 = t_2\\).</li> </ol> </li> </ol> <p>Let us translate the above logic into C++ as follows: <pre><code>int compareTime (const Time &amp;t1, const Time &amp;t2)\n{\n    if (t1.hour &gt; t2.hour)\n        return 1;\n    else if (t1.hour &lt; t2.hour)\n        return -1;\n    else if (t1.minutes &gt; t2.minutes)\n        return 1;\n    else if (t1.minutes &lt; t2.minutes)\n        return -1;\n    else\n        return 0;\n}\n</code></pre></p> <p>To improve your logical thinking, here is another solution using the conditional operator (<code>?:</code>): <pre><code>int compareTime (const Time &amp;t1, const Time &amp;t2) \n{\n    if (t1.hour == t2.hour)\n        return (t1.minute == t2.minute)? 0 : (t1.minute &gt; t2.minute)? 1 : -1;\n    else \n        return (t1.hour &gt; t2.hour)? 1 : -1;\n}\n</code></pre></p> <p>Now, let us shift our attention to the second function, which is <code>addMinutes()</code>. </p> <p>The semantics of this operation is as follows. Let <code>t1</code> be a variable of type <code>Time</code> where <code>t1</code> is set to 10:30. Now:</p> <ul> <li><code>addMinutes(t1, 10)</code> should update <code>t1</code> to be 10:40</li> <li><code>addMinutes(t1, 40)</code> should update <code>t1</code> to be 11:10</li> </ul> <p>The function definition might be: <pre><code>void addMinutes (Time &amp;t, int minutes)\n{\n    t.minutes += minutes;\n    if (t.minutes &gt;= 60) {\n        t.minutes -= 60;\n        t.hour ++;\n    }\n}\n</code></pre> However,  the operation <code>addMinutes()</code> has no result (since the funstion is defined as <code>void</code> function). Logically, this operation should have a value, which is the updated time. Here is how? <pre><code>Time&amp; addMinutes (Time &amp;t, int minutes)\n{\n    t.minutes += minutes;\n    if (t.minutes &gt;= 60) {\n        t.minutes -= 60;\n        t.hour ++;\n    }\n    return t;\n}\n</code></pre> Here, the function returns a reference to <code>Time</code>, which means it returns the object <code>t</code> itself. In other words, the result of operation <code>addMinutes(t, m)</code> is the object <code>t</code> (of course, after adding <code>m</code> minutes).</p> <p>Here is the complete program: <pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nstruct Time \n{\n    int hour;\n    int minutes;\n};\n\nTime subtractTime (const Time&amp;, const Time&amp;);\nvoid printTime (const Time&amp;);\nint compareTime (const Time&amp;, const Time&amp;);\nTime&amp; addMinutes (Time &amp;, int); \n\nint main() \n{\n    char dummy;     // to read ':'\n    Time start;     // the starting time\n    Time end;       // the ending time\n\n    std::cout &lt;&lt; \"Enter the starting time (HH:MM): \";\n    std::cin &gt;&gt; start.hour &gt;&gt; dummy &gt;&gt; start.minutes;\n    std::cout &lt;&lt; \"Enter the ending time (HH:MM): \";\n    std::cin &gt;&gt; end.hour &gt;&gt; dummy &gt;&gt; end.minutes;\n\n    switch (compareTime(end, start)) {\n    case -1:\n        std::cout &lt;&lt; \"Error: The starting time cannot be after ending time. Try again.\\n\";\n        return 1;\n    case 0: \n        std::cout &lt;&lt; \"Maybe the event has been cancelled!!!\\n\"; \n        break;\n    case 1:\n        std::cout &lt;&lt; \"The event duration is \";\n        printTime(subtractTime(end, start));\n        std::cout &lt;&lt; \"\\n\";\n    }\n    std::cout &lt;&lt; \"The event has been extended for another 15 minutes\\n\";\n    std::cout &lt;&lt; \"The new event duration is \";\n    printTime(subtractTime(addMinutes(end, 15), start));\n\n    return 0;\n}\n\nTime subtractTime (const Time &amp;t1, const Time &amp;t2)\n{\n    int h = t1.hour;\n    int m = t1.minutes;\n\n    if (t2.minutes &gt; m) {\n        m = m + 60;\n        h = h - 1;\n    }\n    return Time{h-t2.hour, m-t2.minutes};\n}\n\nvoid printTime (const Time &amp;t)\n{\n    std::cout    \n        &lt;&lt; std::setfill('0') \n        &lt;&lt; std::setw(2) &lt;&lt; t.hour \n        &lt;&lt; ':' \n        &lt;&lt; std::setw(2) &lt;&lt; t.minutes;\n}\n\nint compareTime (const Time&amp; t1, const Time&amp; t2)\n{\n    if (t1.hour == t2.hour)\n        return (t1.minutes == t2.minutes)? 0 : (t1.minutes &gt; t2.minutes)? 1 : -1;\n    else \n        return (t1.hour &gt; t2.hour)? 1 : -1;\n}\n\nTime&amp; addMinutes (Time&amp; t, int minutes)\n{\n    t.minutes += minutes;\n    if (t.minutes &gt;= 60) {\n        t.minutes -= 60;\n        t.hour ++;\n    }\n    return t;\n}\n</code></pre></p>"},{"location":"lectures/lec011/#read-only-lvalue-and-rvalue-function-calls","title":"READ-ONLY: Lvalue and Rvalue Function Calls","text":"<ul> <li>Consider the following function prototypes:     <pre><code>Time subtractTime (const Time&amp;, const Time&amp;);   // return type is non-reference\n</code></pre>     and     <pre><code>Time&amp; addMinutes (Time&amp;, int); // return type is a reference\n</code></pre></li> <li>The function call <code>subtractTime(a, b)</code> can be expressed as \\(a - b\\). The compiler creates a temporary object to hold the value of \\(a - b\\). Similarly, the <code>subtractTime(a, b)</code> creates a temporary object as a return value. So, this function call is an Rvalue.</li> <li>The function call <code>addMinutes(a, m)</code> return the object <code>a</code> itself after adding <code>m</code> minutes. This function call is quite equivalent to <code>a+=m</code>. So, the function <code>addMinutes()</code> is an Lvalue.</li> <li>Generally, a function call whose return type is non-reference is considered Rvalue. </li> <li>A function call whose return type is a reference is considered Lvalue. </li> <li>Now, let us the consider the following example:     <pre><code>addMinutes(subtractTime(a, b), m);\n</code></pre> This expression is illegal because the <code>addMinutes()</code> cannot accept an Rvalue. These function calls are quite equivalent to <code>(a-b)+=m</code>. As you can see, the LHS is not an Lvalue.</li> </ul>"},{"location":"lectures/lec011/#exercises","title":"Exercises","text":"<p>Exercise</p> <ol> <li> <p>Consider the following definition:     <pre><code>struct ShoeType\n{\n    char style;\n    double price;\n};\n</code></pre></p> <p>Given the previous structure-type definition, what will be the output produced by the following code? <pre><code>ShoeType shoe1 = {'A', 25000.00};\nShoeType shoe2 = {};\ncout &lt;&lt; shoe1.style &lt;&lt; \" SDG\" &lt;&lt; shoe1.price &lt;&lt; endl;\n\nshoe2 = shoe1;\nshoe2.price = shoe2.price / 2;\ncout &lt;&lt; shoe1.style &lt;&lt; \" SDG\" &lt;&lt; shoe1.price &lt;&lt; endl;\n</code></pre></p> </li> <li> <p>Write a definition for a structure type for records consisting of an employee identification number (ID number), gender (which is either male or female), birthdate (which is dd/mm/yyyy), monthly salary, and contract status (which is either permanent or temporary). Represent the contract status as one of the two <code>char</code> values 'P' and 'T'. Call the structure type <code>EmployeeRecord</code>.</p> </li> <li> <p>Update the Time Program version (3.0) by adding a binary operation, called <code>addTime</code>, such that <code>addTime(t1, t2)</code> will perform \\(t_1 + t_2\\).   </p> </li> <li> <p>Write a structure called <code>Temperature</code>. It has two members: <code>degree</code> (of type double) and <code>scale</code> (of type char). The scale member can be either 'C' for Celsius or 'F' for Fahrenheit. Define a conversion function that when it receives a temperature from one scale, it will return the equivalent temperature in the other scale. Then write a mian program which:</p> <ol> <li>Asks the user to enter the temperature along with its scale. Then createsa a <code>Temperature</code> object with the inserted input.</li> <li>Create a different <code>Temperature</code> object after invoking the conversion function. </li> <li>Print both temperatures to screen monitor</li> </ol> <p>The conversion formulas are:</p> <ul> <li>From \\(F\\) to \\(C\\), \\(C = 5/9 \\times (F - 32)\\).</li> <li>From \\(C\\) to \\(F\\), \\(F= 9/5 \\times C - 32\\).</li> </ul> </li> </ol>"},{"location":"lectures/lec011/#enumeration","title":"Enumeration","text":"<ul> <li>An enumerated data type is a simple UDT. It specifies its values (known as enumerators) as symbolic constants.     Example of enumerated data type<pre><code>enum Color {RED, GREEN, BLUE};\n</code></pre><ul> <li>The keyword <code>enum</code> announces that this is an enumerated-type definition.</li> <li>The identifier <code>Color</code> is the name of the enumerated-type. </li> <li>The identifiers RED, GREEN and BLUE, which are listed inside the braces, are known as enumerators.</li> <li>The enumerators represent the values that belong to the <code>Color</code> data type.</li> <li>Enumerators are not string literals. They are symbolic constants.</li> </ul> </li> <li>What operations does the compiler know on enumberated data type?<ul> <li>Initialization</li> <li>Assignment operation (<code>=</code> only)</li> <li>Comparisons (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>)</li> <li>Automatically convert an enumerator to its integer value (i.e., from enumerated data type to <code>int</code>). For example:<ul> <li>RED is coverted to 0, GREEN to 1, and BLUE to 2.</li> </ul> </li> <li>Static casting: <code>static_cast&lt;enumerated-data-type&gt;(int)</code> to convert from <code>int</code> to enumerated data type.</li> </ul> </li> <li>Enumerations are used to represent small sets of integer values. They are used to make code more readable and less error-prone than it would have been had the symbolic (and mnemonic) enumerator names not been used.</li> <li> <p>Examples:</p> <ul> <li>Define a variable of type <code>Color</code>:     <pre><code>Color c;\n</code></pre></li> <li>Inilialize enumerated variables:     <pre><code>Color c = GREEN;        // c is GREEN\nColor d = Color(0);     // d is RED - Type casting\n\nColor e = 2;            // Error\n</code></pre></li> <li>Assign a new color for variable <code>c</code>:     <pre><code>c = RED;\n</code></pre></li> <li> <p>Print the value of <code>c</code> <pre><code>c = RED;\ncout &lt;&lt; \"c = \" &lt;&lt; c &lt;&lt; endl;\n</code></pre>     The output will be:</p> <p>Output</p> <p>c = 0</p> </li> <li> <p>You can assign an enumerator to an integer variable:     <pre><code>int cl;\ncl = BLUE;      // Ok!\n</code></pre></p> </li> </ul> </li> <li> <p>Here is a sample code for traffic light:</p> </li> </ul> <p>Example</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\n// Traffic Light\nenum TLight {RED, YELLOW, GREEN};\n\n// Function prototypes\nTLight next (TLight);       // next traffic color\nstring toString (TLight);   // convert RED to \"RED\", and so on.\n\nint main()\n{\n    TLight x  = YELLOW;\n    TLight y = GREEN;\n\n    cout &lt;&lt; \"Current light in x: \" &lt;&lt; toString(x) &lt;&lt; endl;\n    cout &lt;&lt; \"   Next light in x: \" &lt;&lt; toString(next(x)) &lt;&lt; endl;\n    cout &lt;&lt; \"Current light in y: \" &lt;&lt; toString(y) &lt;&lt; endl;\n    cout &lt;&lt; \"   Next light in y: \" &lt;&lt; toString(next(y)) &lt;&lt; endl;\n}\n\nTLight next (TLight t)\n{\n    switch (t)\n    {\n        case RED: return YELLOW;\n        case YELLOW: return GREEN;\n        case GREEN: return RED;\n        default: return RED;\n    }\n}\n\nstring toString (TLight t)\n{\n    switch(t)\n    {\n        case RED: return \"RED\";\n        case YELLOW: return \"YELLOW\";\n        case GREEN: return \"GREEN\";\n        default: return \"UNKNOWN\";\n    }\n}\n</code></pre>"},{"location":"lectures/lec011/#using-math-operators-to-change-the-value-of-an-enum-variable","title":"Using Math Operators to Change the Value of an <code>enum</code> Variable","text":"<ul> <li> <p>Let's examine the highlighted line:     <pre><code>Color c1 = RED;\nColor c2;\nc2 = c1 + 1;    // Error\n</code></pre></p> <p>The compiler starts by evaluting <code>c1 + 1</code>. It converts <code>c1</code> to <code>int</code> automatically. So, the expression becomes <code>0 + 1</code>, which is <code>1</code>. Now, the compiler tries to assign <code>1</code> to <code>c2</code>. However, the compiler does not know how to do that.</p> </li> <li> <p>To resolve this problem, you must use static casting as follows:     <pre><code>Color c1 = RED;\nColor c2;\nc2 = static_cast&lt;Color&gt;(c1 + 1);    // Ok\n</code></pre></p> </li> </ul>"},{"location":"lectures/lec011/#enum-class-data-type","title":"<code>enum class</code> Data type","text":"<ul> <li>The <code>class</code> after the <code>enum</code> specifies that an enumeration is strongly typed and that its enumerators are scoped. For example:     <pre><code>enum class Day {Sun, Mon, Tue, Wed, Thu};\nenum class Weather {Rain, Sun};\n\nDay d = Day::Sun;           // This is Ok\nDay t = Sun;                // Error! which Sun\nWeather w = Weather::Sun;   // Ok.\n</code></pre></li> </ul>"},{"location":"lectures/lec011/#more-about-enumeration","title":"More about Enumeration","text":"<ul> <li>By default, the enumerators are represented by the integer values 0, 1, 2, and so forth.</li> <li>However, we can specify the values to be represented:     <pre><code>enum class Color {RED=1, YELLOW, GREEN=4};\n</code></pre>     The enumerator <code>RED</code> will be represented by the value 1, the enumerator <code>YELLOW</code> will be represented by the value 2, and the enumerator <code>GREEN</code> will be represented by value <code>4</code>.</li> <li>Another example:     <pre><code>enum class Color {RED, ORANGE, YELLOW = 9, GREEN, BLUE};\n</code></pre>     The representations will be: <code>RED</code> as 0, <code>ORANGE</code> as 1, <code>YELLOW</code> as 9, <code>GREEN</code> as 10, <code>BLUE</code> as 11.</li> </ul>"},{"location":"lectures/lec011/#anonymous-udts","title":"Anonymous UDTs","text":"<ul> <li> <p>Structure tag and enumerated-type name are optional.</p> </li> <li> <p>Consider the following example:     <pre><code>int main() {\n    struct {int x; int y;} p;\n    .\n    .\n}\n</code></pre>     Notice that the structure has no tag and <code>p</code> is variable of anonymous structure (consists of two integers).</p> <p>We can write: <pre><code>p.x = 10;\np.y = 12;\n</code></pre></p> </li> <li> <p>Anonymous structures are useful when building complex structures:     <pre><code>struct Student {\n    string name;    // student name\n    string index;   // student index number\n    struct {\n        int day;\n        int month;\n        int year;\n    } birthday;      // student birth date\n    double cgpa;     // student commulated GPA\n};\n</code></pre></p> </li> <li> <p>Similarly, we can have anonymous enumerated type:     <pre><code>enum {RED, YELLOW, GREEN};\n</code></pre>     This declaration creates the enumerators. We just can't use the data type to define variables, because the type does not have a name.</p> </li> </ul>"},{"location":"lectures/lec011/#read-only-day-of-week","title":"READ-ONLY: Day of Week","text":"<p>The following program finds the day of the week that corresponds to a given date. For example, if you input 1/1/2023, the program prints out the corresponding day, which is \"Sunday\". The algorithm for finding the day of week is taken from Wikipedia. If you want to learn programming, then you must type this program by yourself (not copy and paste). Don't worry! I am not going to ask you this program in the final exam. The purpose of this example is to broaden your knowledge in software development.</p> <p>Don\u2019t worry, also, if you did not understand the following lines:</p> <pre><code>ostream&amp; operator &lt;&lt; (ostream&amp;, const Date);\nostream&amp; operator &lt;&lt; ( ostream &amp; , const Day);\n</code></pre> <p>These are known as operator overloading (Similar to function overloading). We will discuss operator overloading in this course.</p> <p>Exmaple</p> <pre><code>// this program prints the day of any given date\n#include &lt;iostream&gt;\n\nusing namespace std;\n\n// Day data type\nenum class Day {SUN, MON, TUE, WED, THU, FRI, SAT};\n\n// Date data type\nstruct Date {\n    int day;\n    int month;\n    int year;\n};\n\n// Operations\nDay dayofweek (const Date&amp;);\nDate inputDate(string);\nostream&amp; operator&lt;&lt; (ostream&amp;, const Date);\nostream&amp; operator&lt;&lt; (ostream&amp;, const Day);\n\n// main function\n//\nint main()\n{\n    Date date;\n    Day day;\n\n    date = inputDate(\"Enter a date\");\n    day = dayofweek(date);\n    cout &lt;&lt; \"The day of \" &lt;&lt; date &lt;&lt; \" is \" &lt;&lt; day &lt;&lt; endl;\n\n    return 0;\n}\n\n// inputDate()\n//\nDate inputDate (string prompt)\n{\n    int dd, mm, yy;\n    char dummy;\n\n    cout &lt;&lt; prompt &lt;&lt; endl;\n    cout &lt;&lt; \"\\t  Day: \"; cin &gt;&gt; dd; \n    cout &lt;&lt; \"\\tMonth: \"; cin &gt;&gt; mm; \n    cout &lt;&lt; \"\\t Year: \"; cin &gt;&gt; yy;\n\n    return Date{dd, mm, yy};\n}\n\n// dayofweek function\n// source: from the Internet\nDay dayofweek(const Date&amp; date)\n{\n    auto [d, m, y] = date;      // unpacking date\n    static int t[] = { 0, 3, 2, 5, 0, 3,\n                5, 1, 4, 6, 2, 4 };\n    int dd;\n    y -= m &lt; 3;\n    dd = (y + y / 4 - y / 100 +\n        y / 400 + t[m - 1] + d) % 7;\n\n    return Day(dd);\n}\n\n// This function makes Date value printable\n//\nostream&amp; operator&lt;&lt; (ostream&amp; out, const Date date) \n{\n    out &lt;&lt; date.day &lt;&lt; \"/\" &lt;&lt; date.month &lt;&lt; \"/\" &lt;&lt; date.year;\n    return out;\n}\n\n// This function makes Day value printable\n//\nostream&amp; operator&lt;&lt;(ostream&amp; out, const Day day)\n{\n    switch(day)\n    {\n        case Day::SUN: return out &lt;&lt; \"Sunday\";\n        case Day::MON: return out &lt;&lt; \"Monday\";\n        case Day::TUE: return out &lt;&lt; \"Tuesday\";\n        case Day::WED: return out &lt;&lt; \"Wednesday\";\n        case Day::THU: return out &lt;&lt; \"Thursday\";\n        case Day::FRI: return out &lt;&lt; \"Friday\";\n        case Day::SAT: return out &lt;&lt; \"Saturday\";\n    }\n\n    return out;\n}\n</code></pre>"},{"location":"lectures/lec021/","title":"Lecture 2: Pointers and Dynamic Arrays","text":""},{"location":"lectures/lec021/#the-address-of-an-object","title":"The Address of an Object","text":"<ul> <li>Recall the following:</li> </ul> <p>The semantics of:</p> <pre><code>int length {100};\n</code></pre> <p> </p> <p>This is a definition statement:</p> <ol> <li>It creates a new object by allocating four-byte memory.</li> <li>The new object will be named <code>length</code>.</li> <li>The data type of <code>length</code> is <code>int</code>.</li> <li>The object will be initialized with the value of 100.</li> </ol> <p></p> <ul> <li> <p>The computer's memory (RAM) is divided into a set of cells (memory locations). Each cell has an index (we call it memory address). The first cell has index 0, the next cell has index 1, and so on.</p> </li> <li> <p>The size of the cell is fixed, which is 1 byte. </p> </li> <li> <p>You can visualize RAM as a very large array where each element in the array is 1-byte cell. The diagram shows a computer's memory of size 64KB = (65536 Bytes). The first memory location has address 0 and the last memory location has address 65535.</p> </li> <li> <p>It's a custom to write the memory addresses in hexadecimal notation. However, in this course, we write memory addresses in decimal format. So, the value of <code>0x0CD24</code> is equal to 52,516 in decimal.</p> </li> </ul> <p></p> <ul> <li> <p>The second diagram shows how the object named by <code>length</code> is stored in memory. The run-time system allocates 4 bytes starting from memory location 52516. Therefore, the memory locations 52516, 52517, 52518, and 52519 are reserved for the object named by <code>length</code>. These locations all together are initialized with value 100.</p> </li> <li> <p>You should notice that the object's address is the address of the first byte allocated. In our example, the address of the object named by <code>length</code> is 52516 or <code>0x0CD24</code>.</p> </li> </ul> <p>Summary</p> <ol> <li>Computer's memory is divided into 1-byte memory locations,</li> <li>Each byte of memory has a unique address.</li> <li>An object's address is the address of the first byte allocated to that object.</li> </ol>"},{"location":"lectures/lec021/#the-address-of-operator","title":"The Address-of Operator (<code>&amp;</code>)","text":"<ul> <li>The operator <code>&amp;</code> in front of a variable name produces the address of the object that it refers to. The <code>&amp;</code> is simply called the address-of operator.</li> <li>For example, if the object named by <code>length</code> is located at address 52516, then the expression <code>&amp;length</code> (read as the address of length) returns the address 52516. </li> </ul> <p>Example (1)<pre><code>// This program uses the &amp; operator to determine\n// an object's address and sizeof operator to\n// determine its size\n#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int v {25};\n\n    cout &lt;&lt; \"The compiler has allocated \" &lt;&lt; sizeof(v) \n         &lt;&lt; \" byte(s) at memory address \" &lt;&lt; &amp;v \n         &lt;&lt; \" for the object named by 'v'\" &lt;&lt; endl;\n    cout &lt;&lt; \"The value in the object is \" &lt;&lt; v &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> Here is a sample output</p> <p>Output</p> <pre><code>The compiler has allocated 4 byte(s) at memory address 0x4aa4fffbac for the object named by 'v'\nThe value in the object is 25\n</code></pre> <ul> <li>Let us consider another example. The type <code>uintptr_t</code> is used to display the memory addresses as decimals.</li> </ul> <p>Example (2)<pre><code>#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\nusing namespace std;\n\nint main()\n{\n    char c1 = 'a';\n    char c2 = 'b';\n    int   x = 30;\n    double y = 1.4;\n\n    cout &lt;&lt; \"sizeof(c1) is \" &lt;&lt; sizeof(c1) &lt;&lt; \", &amp;c1 is \" &lt;&lt; (uintptr_t)&amp;c1 &lt;&lt; endl;\n    cout &lt;&lt; \"sizeof(c2) is \" &lt;&lt; sizeof(c2) &lt;&lt; \", &amp;c2 is \" &lt;&lt; (uintptr_t)&amp;c2 &lt;&lt; endl;\n    cout &lt;&lt; \"sizeof(x)  is \" &lt;&lt; sizeof(x)  &lt;&lt; \", &amp;x  is \" &lt;&lt; (uintptr_t)&amp;x &lt;&lt; endl;\n    cout &lt;&lt; \"sizeof(y)  is \" &lt;&lt; sizeof(y)  &lt;&lt; \", &amp;y  is \" &lt;&lt; (uintptr_t)&amp;y &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre> A sample output is shown below:</p> <p>Output</p> <pre><code>sizeof(c1) is 1, &amp;c1 is 29523704431 \nsizeof(c2) is 1, &amp;c2 is 29523704430 \nsizeof(x)  is 4, &amp;x  is 29523704424 \nsizeof(y)  is 8, &amp;y  is 29523704416 \n</code></pre>"},{"location":"lectures/lec021/#the-concept-of-pointers","title":"The Concept of Pointers","text":""},{"location":"lectures/lec021/#mail-system","title":"Mail System","text":"<ul> <li>Mail is a system for physically transporting letters, postcards, and parcels.</li> <li>Each mailbox is uniquely identified by its address.</li> <li>Letters, postcards and parcels must contain the sender address and the recipient address.</li> <li>Postage stamps are attached to the letter/postcards/parcels to cover the cost of transportation.</li> <li>Now, how are large packages delivered to the recipients?<ul> <li>The postman inserts a notice that contains the address of where the package is actually located.</li> <li>This arrangement is quite similar to the concept of pointers.</li> </ul> </li> </ul>"},{"location":"lectures/lec021/#pointers","title":"Pointers","text":"<ul> <li> <p>A pointer is an object that contains information about     </p> <ol> <li>where the actual object is located, and</li> <li>the data type of that object.</li> </ol> </li> <li> <p>In the diagram, assume there are two objects stored in the computer's memory. One object is named <code>length</code> located at address 52516, and the other object is named <code>ptr</code> located at address 52508.</p> </li> <li>The value in <code>length</code> is <code>100</code>, which is an integer value.     <pre><code>int length = 100;\n</code></pre></li> <li> <p>The value in <code>ptr</code> is <code>52516</code>, which is the memory address of the object named by <code>length</code>. </p> </li> <li> <p>Currently, the variable <code>ptr</code> has one information, which is the memory location of the object named <code>length</code>. Due this inofrmation, we say the variable <code>ptr</code> is a pointer, becuase it points to the object named <code>length</code>. </p> </li> <li> <p>You should visualize this arrangement as follows. Let us call this image the \"pointer diagram\":</p> <p></p> </li> <li> <p>When dealing with pointers, always try to draw the pointer diagram. It helps you to write your code correctly.</p> </li> <li> <p>In the following sub-sections, we will learn how to achieve the above diagram.</p> </li> <li> <p>Now, the object located at memory address 52516 can be accessed:</p> <ol> <li>by the variable <code>length</code>, directly. Or,</li> <li>by the variable <code>ptr</code>, indirectly</li> </ol> </li> <li> <p>There is still one missing information: the type of the object that the pointer <code>ptr</code> points to. This information is acquired when we declare a pointer.</p> </li> </ul>"},{"location":"lectures/lec021/#pointer-definition","title":"Pointer Definition","text":"<ul> <li> <p>The definition of a pointer variable is quite similar to the definition of any ordinary variable.</p> </li> <li> <p>Here is an example:     <pre><code>int *ptr;\n</code></pre></p> <ul> <li><code>int</code> is the type sepcifier,</li> <li>The asterisk <code>*</code> followed by <code>ptr</code> are known as a declarator, which declares <code>ptr</code> as a pointer.</li> </ul> </li> <li> <p>The definition statement above should read \"ptr is a pointer to an integer object.\"</p> </li> </ul> <p>What is the semantics of</p> <pre><code>double *dptr;\n</code></pre> <p></p> <p>This is a definition statement:</p> <ol> <li>It creates a new object by allocating four-byte or eight-byte memory.</li> <li>The new object will be named <code>dptr</code>.</li> <li>The data type of <code>dptr</code> is a pointer (which is a memory address)</li> <li>The data type of the object that <code>dptr</code> points to is <code>double</code>.</li> <li>The object is not initialized.</li> </ol>"},{"location":"lectures/lec021/#assignment-with-pointers","title":"Assignment with Pointers","text":"<ul> <li>Once a pointer variable is defined, we can assign a value to that pointer. </li> <li>Remember that pointers always hold memory addresses.</li> <li> <p>Consider the following code:     <pre><code>int length = 100;\nint *ptr;\n\nptr = &amp;length;\n</code></pre></p> <p>Let us read the code:</p> <ul> <li>define a new object named <code>length</code> of type <code>int</code> with an initial value 100.</li> <li>define a new object named <code>ptr</code> of type pointer that points to an object of type <code>int</code>. </li> <li>The last statement (the highlighted line) is an assignment statement, which reads \"Put the address of <code>length</code> into the object named by <code>ptr</code>\". </li> <li> <p>According to this last statement, the pointer diagram, which illustrates the relationship between <code>ptr</code> and <code>length</code>, is:</p> <p></p> </li> </ul> </li> </ul>"},{"location":"lectures/lec021/#indirection-operator","title":"Indirection Operator","text":"<ul> <li>The real benefit of pointers is that they allow you to indirectly access and modify the object being pointed to. </li> <li>In the previous code, <code>ptr</code> could be used to change the contents of the variable <code>length</code>. </li> <li>This is done with the indirection operator (sometimes it is also called dereference operator), which is an asterisk <code>*</code>.</li> <li> <p>Le us consider the following program:     <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int length = 100;       // integer variable\n    int *ptr;               // pointer variable\n\n    ptr = &amp;length;          // ptr points to length\n    cout &lt;&lt; \"Length = \" &lt;&lt; *ptr &lt;&lt; endl;\n\n    return 0;\n}\n</code></pre></p> <p>Output</p> <p>Length = 100</p> <p>Look at the highlighted line: <pre><code>cout &lt;&lt; \"Length = \" &lt;&lt; *ptr &lt;&lt; endl;\n</code></pre> The asterisk before <code>ptr</code> is a indirection operator. The expression <code>*ptr</code> returns the object named <code>length</code>. So, the above statement is exactly the same as: <pre><code>cout &lt;&lt; \"Length = \" &lt;&lt; length &lt;&lt; endl;\n</code></pre></p> </li> <li> <p>Another example     <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    int x = 20, y = 53, z = 67;\n    int *ptr;\n\n    ptr = &amp;x;       // ptr points to x\n    *ptr += 100;    // add 100 to the value of x\n\n    ptr = &amp;y;       // ptr points to y\n    *ptr += 100;    // add 100 to the value of y\n\n    ptr = &amp;z;       // ptr points to z\n    *ptr += 100;    // add 100 to the value of z\n\n    cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; \", y = \" &lt;&lt; y &lt;&lt; \", z = \" &lt;&lt; z &lt;&lt; endl;\n    return 0;\n}\n</code></pre></p> <p>Output</p> <p>x = 120, y = 153, z = 167</p> </li> </ul> <p>Operators vs Declarators</p> <p>In C++, the tokens <code>*</code> and <code>&amp;</code> have different meanings based on the context of C++ statements.</p> <ol> <li>If <code>*</code> and <code>&amp;</code> are appeared in the declaration/defintion statement (without initialization), then they will be interpreted as declarators.</li> <li>If <code>*</code> and <code>&amp;</code> are appeared in initialization, then they will be interpreted as operators.</li> <li>If <code>*</code> and <code>&amp;</code> are appeared in expression, they will be interpreted as operators.</li> </ol> <p>Let us consider the following program: <pre><code>#include &lt;iostream&gt;\n\nint main()\n{\n    int x = 10, y = 12;\n    int &amp;z = x;\n    int *p;\n\n    p = &amp;y;\n    *p += 3;\n    z = x * y;\n    std::cout &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre></p> <ol> <li>The token <code>&amp;</code>, at line 6, is a declarator. It declares <code>z</code> as a reference to the object named <code>x</code>.</li> <li>The token <code>*</code>, at line 7, is a declarator. It declares <code>p</code> as a pointer to an object of type <code>int</code>.</li> <li>The token <code>&amp;</code>, at line 9, is an address-of operator. The expression <code>&amp;y</code> returns the memory address of <code>y</code>.</li> <li>The token <code>*</code>, at line 10, is a dereference operator. The expression <code>*p</code> returns the object named <code>y</code>.</li> <li>The token <code>*</code>, at line 11, is a multiplication operator. The expression <code>x * y</code>will be evaluated based on the values in <code>x</code> and <code>y</code>.  </li> </ol>"},{"location":"lectures/lec021/#more-examples","title":"More examples","text":"<p>For the following examples, consider the following definitions: <pre><code>double d1 = 2.3;\ndouble d2 = 5.5;\ndouble *p;\ndouble *q;\n</code></pre></p> <ol> <li> <p>Tell me the C++ statement to establish the following  pointer diagram:</p> <pre><code>%%{init: {\"flowchart\": {\"htmlLabels\": false}} }%%\ngraph LR\n    p --&gt; d1[\"`**d1**`\" = 2.3]</code></pre> Click to see the answer <p><code>p = &amp;d1;</code></p> </li> <li> <p>Draw the pointer diagram when the following statement is executed:     <pre><code>q = &amp;d2;\n</code></pre></p> Click to see the answer <pre><code>%%{init: {\"flowchart\": {\"htmlLabels\": false}} }%%\ngraph LR\n    q --&gt; d2[\"`**d2**`\" = 5.5]</code></pre> </li> <li> <p>If <code>p</code> points to <code>d1</code> and <code>q</code> points to <code>d2</code>, then draw the pointer diagram after executing the following lines:     <pre><code>*p = 3.0;\n*q = 6.0;\n</code></pre></p> Click to see the answer <pre><code>*p = 3.0;   // assign 3.0 to d1\n*q = 6.0;   // assign 6.0 to d2\n</code></pre> <pre><code>%%{init: {\"flowchart\": {\"htmlLabels\": false}} }%%\ngraph LR\n    p --&gt; d1[\"`**d1**`\" = 3.0]\n    q --&gt; d2[\"`**d2**`\" = 6.0]</code></pre> </li> <li> <p>If <code>p</code> points to <code>d1</code> and <code>q</code> points to <code>d2</code>, then draw the pointer diagram after executing the following line:     <pre><code>p = q;\n</code></pre></p> Click to see the answer <pre><code>%%{init: {\"flowchart\": {\"htmlLabels\": false}} }%%\ngraph LR\n    q --&gt; d2[\"`**d2**`\" = 5.5]\n    p ~~~ d1[\"`**d1**`\" = 2.3]\n    p --&gt; d2</code></pre> </li> <li> <p>If <code>p</code> points to <code>d1</code> and <code>q</code> points to <code>d2</code>, then draw the pointer diagram after executing the following line:     <pre><code>*q = *p;\n</code></pre></p> Click to see the answer <pre><code>%%{init: {\"flowchart\": {\"htmlLabels\": false}} }%%\ngraph LR\n    p ---&gt; d1[\"`**d1**`\" = 2.3]            \n    q ---&gt; d2[\"`**d2**`\" = 2.3]</code></pre> </li> </ol>"},{"location":"lectures/lec021/#pointer-initialization","title":"Pointer Initialization","text":"<ul> <li>You can initialize the pointer variable during the construction. For example:     <pre><code>int length = 100;\nint *ptr = &amp;length;\n</code></pre></li> <li>Remember that <code>= &amp;length</code> is an initializer.</li> <li>Another example:     <pre><code>float x{2.5};\nfloat *fptr{&amp;x};\n</code></pre></li> <li> <p>If you inadvertently use an uninitialized pointer variable, you will be affecting some unknown location in memory. For that reason, it is a good idea to initialize pointer variables with the special value <code>nullptr</code>.     <pre><code>char *p{nullptr};   // new style\n</code></pre></p> <pre><code>char *p{NULL};      // old style\n</code></pre> </li> <li> <p>If a pointer is pointing to <code>NULL</code> or <code>nullptr</code>, this pointer is pointing to nothing. Null pointer is the address 0. We visualize this meaning using one of the following pointer diagrams:</p> <p></p> </li> </ul>"},{"location":"lectures/lec021/#summary","title":"Summary","text":"<p>The following table provides a summary of pointer's operations:</p> Token Syntactic context Example Meaning (Action) * declarator <code>int *p</code> create/declare a pointer object * unary operator <code>*p</code> dereference p; the object that the pointer <code>p</code> points to * binary operator <code>a * b</code> multiply a by b &amp; declarator <code>int &amp;p</code> declare p as a reference (alias) of another object &amp; unary operator <code>&amp;p</code> address of p; memory location of p &amp; binary operator <code>a &amp; b</code> bitwise AND operation"},{"location":"lectures/lec021/#pointers-and-arrays","title":"Pointers and Arrays","text":"<ul> <li> <p>Let us re-visit the array definition:</p> <ul> <li> <p>Consider the following array definition:     <pre><code>int a[10];\n</code></pre>     The compiler will perform the following:</p> <ol> <li>It allocates a contiguous memory block of size 40 bytes (since one element occupies 4 bytes).</li> <li>The address of the first byte in the memory block is named <code>a</code>.</li> <li>The data type of each element is <code>int</code></li> </ol> </li> </ul> </li> <li> <p>So, the variable <code>a</code> can be envisioned as just a symbolic constant to the first address in the block. So, <code>a</code> is eventually a pointer, as depicted in the following diagram:     </p> </li> <li> <p>Since <code>a</code> is a constant, you cannot change its value.     <pre><code>a = a + 1;      // Error\n</code></pre></p> </li> <li> <p>We can define a pointer variable that points to the first element in the array:     <pre><code>int a[10];\nint *ptr;\n\nptr = a;    // ptr now points to the first element\n</code></pre></p> <p>or <pre><code>ptr = &amp;a[0];\n</code></pre></p> <p></p> </li> <li> <p>An array, in essence, is a pointer, but it points to a fixed memory location. We say that arrays are constant pointers. </p> </li> <li> <p>If <code>a</code> is an array, then the elements can be accessed using array notation or pointer notation, as illustrated in the following table:</p> Element Array notation Pointer notation First element <code>a[0]</code> <code>*a</code> Second element <code>a[1]</code> <code>*(a + 1)</code> Third element <code>a[2]</code> <code>*(a + 2)</code> nth element <code>a[n-1]</code> <code>*(a + (n-1))</code> </li> <li> <p>When working with arrays, remember the following rule:</p> <p><code>array[index]</code> is equivalent to <code>*(array + index)</code></p> </li> </ul>"},{"location":"lectures/lec021/#pointer-arithmetic-logic","title":"Pointer Arithmetic &amp; Logic","text":"<ul> <li> <p>C++ compiler can perform the following operations:</p> <ol> <li>add an integer to address (address + integer),</li> <li>subtract an integer value from an address (address - integer), </li> <li>subtract an address from another address (address - address, and</li> <li>compare two addresses using <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code>.</li> </ol> </li> <li> <p>Pointer arithmetic is different from ordinary arithmetic. For example, suppose your program contains the following code:     <pre><code>double numbers[10] = {1.0, 2.1, 3.5, 4.1, 5.11, 6.2, 7.7, 8.1, 9.5, 10.3};\ndouble *d{numbers};\n</code></pre></p> <ul> <li>The pointer <code>d</code> points to the array <code>numbers</code>.</li> <li>If the array is located at address 2000, then the value of <code>d</code> is also 2000.</li> <li>The expression <code>d + 1</code> DOES NOT simply add 1 to the number in <code>d</code>. If the size of <code>double</code> is eight bytes, then the expression <code>d + 1</code> will evaluate to the memory address 2008. This is equivalent to <code>&amp;d[1]</code>.</li> <li> <p>The expression <code>d + 2</code> evaluates to the memory address 2016. This is equivalent to <code>&amp;d[2]</code>.</p> </li> <li> <p>Suppose <code>d</code> is pointing to the third element as in the following code:     <pre><code>d = &amp;numbers[2];\n</code></pre></p> <p>Then</p> <p></p> Pointer expression Value Array notation <code>d</code> 2016 (address) <code>&amp;numbers[2]</code> <code>*d</code> 3.5 (double) <code>numbers[2]</code> <code>d + 2</code> 2032 (address) <code>&amp;numbers[4]</code> <code>*(d - 1)</code> 2.1  (double) <code>numbers[1]</code> <code>*(d + 4)</code> 7.7 (double) <code>numbers[6]</code> <code>d - 2</code> 2000 (address) <code>numbers</code> or <code>&amp;numbers[0]</code> </li> </ul> </li> </ul>"},{"location":"lectures/lec021/#moving-pointers-forward-backward","title":"Moving Pointers Forward &amp; Backward","text":"<ul> <li> <p>If <code>ptr</code> is a pointer then the expression <code>ptr + 1</code> returns the address of the next element, and the expression <code>ptr - 1</code> returns the address of the previous element, as depicted in the following diagram:</p> <p></p> </li> <li> <p>Thus, the expression <code>ptr = ptr + 1</code> will update the <code>ptr</code> such that <code>ptr</code> will point to the next element. Similarly, the expression <code>ptr = ptr - 1</code> will update the <code>ptr</code> such that <code>ptr</code> will point to the previous element. The following table shows other expressions to update the pointer location:</p> Moving forward Moving backward <code>ptr = ptr + 1</code> <code>ptr = ptr - 1</code> <code>ptr++</code> <code>ptr--</code> <code>++ptr</code> <code>--ptr</code> <code>ptr += 1</code> <code>ptr -= 1</code> <code>ptr += 2</code> <code>ptr -= 2</code> <p>The last row shows how to move the pointer <code>ptr</code> two steps forward or backward.</p> </li> </ul> Example (1)<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    double nums[] = {2.0, 2.3, 4.3, 3.6};\n    constexpr int counts = sizeof(nums)/sizeof(double);\n\n    double sum = 0.0;\n    double *p = nums;   // p points to first element\n    for (int i=0; i&lt;counts; i++) {\n        sum += *p;\n        p = p + 1;      // move to next element\n    }\n    cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; endl;\n    return 0;\n}\n</code></pre> Example (2)<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint main()\n{\n    double nums[] = {2.0, 2.3, 4.3, 3.6};\n    constexpr int counts = sizeof(nums)/sizeof(double);\n\n    double sum = 0.0;\n    double *p = nums;   // p points at the beginning\n    double *q = nums + counts - 1;  // q points at the end\n    for ( ; p &lt;= q; p++) \n        sum += *p;\n\n    cout &lt;&lt; \"sum = \" &lt;&lt; sum &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <p>Self-Check</p> QuestionsAnswers <ol> <li> <p>Write a statement that defines a pointer variable named <code>fltPtr</code>. The variable should be a pointer toa <code>float</code>. Be sure to properly initialize the variable</p> </li> <li> <p>Assume an <code>int</code> variable named <code>value</code> has been defined. Also assume a pointer to integer variable named <code>ptr</code> has been defined. Write a statement that assigns the address of the <code>value</code> variable to the <code>ptr</code> variable.</p> </li> <li> <p>Assume <code>ptr</code> is a pointer variable that points to another object. Write a <code>cout</code> statement that displays the value that <code>ptr</code> points to.</p> </li> <li> <p>What is the output of the following code?     <pre><code>int x = 50, y = 60, z = 70;\nint *ptr = nullptr;\n\ncout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; z &lt;&lt; endl;\nptr = &amp;x;\n*ptr = *ptr + 10;\nptr = &amp;y;\n*ptr += x/2;\nptr = &amp;z;\nz = y - *ptr;\ncout &lt;&lt; x &lt;&lt; \" \" &lt;&lt; y &lt;&lt; \" \" &lt;&lt; z &lt;&lt; endl;\n</code></pre></p> </li> <li> <p>Rewrite the following loop so it uses pointer notation (with the indirection operator) instead of subscript notation.</p> <pre><code>for (int x = 0; x &lt; 100; x++)\n    cout &lt;&lt; arr[x] &lt;&lt; endl;\n</code></pre> </li> <li> <p>Assume <code>ptr</code> is a pointer to an <code>int</code> and holds the address 12000. On a system with 4-byte integers, what address will be in <code>ptr</code> after the following statement?     <pre><code>ptr += 10;\n</code></pre></p> </li> <li> <p>Assume <code>pint</code> is a pointer variable. Is each of the following statements valid or invalid? if any is invalld, why?</p> <ol> <li><code>pint++;</code></li> <li><code>--pint;</code></li> <li><code>pint /= 2</code>;</li> <li><code>pint *= 4;</code></li> <li><code>pint += x;  // Assume x is an</code> <code>int</code></li> </ol> </li> </ol> <ol> <li> <p><pre><code>float *fltPtr{nullptr};\n</code></pre> or <pre><code>float *fltPtr = nullptr;\n</code></pre></p> </li> <li> <pre><code>ptr = &amp;value;\n</code></pre> </li> <li> <pre><code>cout &lt;&lt; *ptr &lt;&lt; endl;\n</code></pre> </li> <li> <pre><code>50 60 70\n60 90 20\n</code></pre> </li> <li> <pre><code>for (int x = 0; x &lt; 100; x++)\n    cout &lt;&lt; *(arr + x) &lt;&lt; endl;\n</code></pre> </li> <li> <p>\\(1200 + 10*4 = 1240\\)</p> </li> <li> <ol> <li>Valid</li> <li>Valid</li> <li>Invalid because dividing address by integer is not allowed</li> <li>Invalid because multiplying address by integer is not allowed.</li> <li>Valid</li> </ol> </li> </ol>"},{"location":"lectures/lec021/#pointers-and-structures","title":"Pointers and Structures","text":""},{"location":"lectures/lec021/#dynamic-arrays","title":"Dynamic Arrays","text":""}]}